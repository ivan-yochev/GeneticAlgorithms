# Решаване на VRP (проблема с планирането на маршрути за превозни средства)
# Представете си, че управлявате голям логистичен център. Трябва да доставите пакети до списък с клиенти, но този път
# разполагате с няколко превозни средства. Какъв е най-добрият начин за разпределение на доставките между тези превозни средства?

# Това е пример за VRP (Vehicle Routing Problem) – обобщение на проблема с търговския пътник (TSP), описан в предишния раздел.
# Основните компоненти на VRP включват:

# Списък с локации, които трябва да бъдат посетени.
# Брой превозни средства, налични за изпълнение на доставките.
# Локация на депо, което служи като начален и краен пункт за всяко превозно средство.
# Проблемът има множество вариации, като няколко депа, доставки с критичен срок, различни видове превозни средства 
# (с различен капацитет и разход на гориво) и други.

# Целта на проблема е да се минимизира определена стойност, която може да бъде дефинирана по различни начини, например:

# Минимизиране на общото време за изпълнение на всички доставки.
# Минимизиране на разходите за гориво.
# Минимизиране на разликата в изминатото време между използваните превозни средства.
# Илюстрация на VRP с три превозни средства показва градовете, маркирани с тъмни кръгове, и депото, обозначено с
# празен квадрат, а маршрутите на трите превозни средства са показани в различни цветове.

# В нашия пример ще се стремим да оптимизираме времето, необходимо за доставяне на всички пакети. Тъй като всички превозни
# средства работят едновременно, тази мярка се определя от превозното средство, което изминава най-дългия маршрут.
# Следователно, можем да направим целта си да минимизираме дължината на най-дългия маршрут сред маршрутите на участващите
# превозни средства. Например, ако разполагаме с три превозни средства, всяко решение ще се състои от три маршрута. 
# Ще оценим всички три маршрута, но за скорирането ще вземем предвид само най-дългия – колкото по-дълъг е маршрутът, 
# толкова по-лош е резултатът. Това по естествен начин ще насърчи всички три маршрута да бъдат по-кратки, както и по-близки 
# по дължина един до друг.

# Благодарение на приликата между двата проблема, можем да използваме кода, който написахме по-рано за решаване на TSP,
# за да решим и VRP.

# За да надградим решението, което създадохме за TSP, можем да представим маршрутизирането на превозните 
# средства по следния начин:

# TSP инстанция, а именно списък с градове и техните координати (или взаимни разстояния).
# Локация на депо, която се избира от съществуващите градове и се представя чрез индекса на този град.
# Брой използвани превозни средства.
# В следващите две подглави ще покажем как да реализирате това решение.

# Представяне на решението
# Както обикновено, първият въпрос, който трябва да адресираме, е как да представим решение на този проблем.
# За да илюстрираме предложеното ни представяне, ще разгледаме пример с 10 града, показан на следната фигура, където 
# местоположенията на градовете са означени с числа от 0 до 9.

# Креативен начин за представяне на кандидатско решение на VRP, като същевременно се запазва сходството с вече решената TSP,
# е чрез използване на списък, който съдържа числата от 0 до 
# (n−1)+(m−1), където:

# n е броят на градовете

# m е броят на превозните средства
# Например, ако броят на градовете е 10, а броят на превозните средства е 3 

# (n=10,m=3), тогава ще имаме списък, съдържащ всички цели числа от 0 до 11, както е показано тук:

# [0, 6, 8, 9, 11, 3, 4, 5, 7, 10, 1, 2]

# Първите 
# n цели числа, което в нашия случай е 0...9, все още представляват градовете, както и преди. Въпреки това, последните 
# m−1 цели числа, 10 и 11 в нашия случай, се използват като разделители (или "сепаратори"), които разделят списъка на маршрути.

# Например, даденият списък [0, 6, 8, 9, 11, 3, 4, 5, 7, 10, 1, 2] ще бъде разделен на следните три маршрута:

# [0, 6, 8, 9]
# [3, 4, 5, 7]
# [1, 2]
# Тази структура позволява лесно и гъвкаво представяне на решения, като се запазва съвместимостта с предишния модел на TSP.

# След това, индексът на местоположението на депото трябва да бъде премахнат, тъй като той не е част от конкретен маршрут.
# Ако, например, местоположението на депото е с индекс 7, тогава получените маршрути ще изглеждат по следния начин:

# [0, 6, 8, 9]
# [3, 4, 5]
# [1, 2]
# Изчисляване на разстоянията
# Когато изчисляваме разстоянието, което всеки маршрут покрива, трябва да помним, че всеки маршрут започва и завършва в
# местоположението на депото (индекс 7).
# Следователно, за да изчислим разстоянията, както и да начертаем маршрутите, ще използваме следните данни:

# [7, 0, 6, 8, 9, 7]
# [7, 3, 4, 5, 7]
# [7, 1, 2, 7]
# Това кандидатско решение е илюстрирано на следващата фигура, като ясно се вижда, че всеки маршрут започва и завършва в депото.

# Този подход осигурява коректно представяне на маршрутите и гарантира, че алгоритъмът правилно отчита началната и крайната 
# точка за всяко превозно средство.

# В следващата подсекция ще разгледаме Python имплементация на тази идея.
# https://github.com/PacktPublishing/Hands-On-Genetic-Algorithms-with-Python-Second-Edition/blob/main/chapter_04/vrp.py

# За да капсулираме проблема VRP, създадохме Python клас, наречен VehicleRoutingProblem. Този клас се намира във файла vrp.py
# и може да бъде намерен на адрес:
# https://github.com/PacktPublishing/Hands-On-Genetic-Algorithms-with-Python-SecondEdition/blob/main/chapter_04/vrp.py.

# Класът VehicleRoutingProblem съдържа инстанция на класа TravelingSalesmanProblem, който се използва като контейнер за 
# индексите на градовете и техните съответстващи местоположения и разстояния.

# При създаването на инстанция на класа VehicleRoutingProblem, вътрешната инстанция на TravelingSalesmanProblem се създава
# и инициализира вътрешно.

# Класът VehicleRoutingProblem се инициализира чрез името на основния TravelingSalesmanProblem, както и чрез индекса на 
# местоположението на депото и броя на превозните средства.

# Освен това, класът VehicleRoutingProblem предоставя следните публични методи:

# getRoutes(indices): Разделя подадения списък от индекси на отделни маршрути, като разпознава индексите, които служат
# като „разделители“.
# getRouteDistance(indices): Изчислява общото разстояние на пътя, който започва от местоположението на депото и преминава 
# през градовете, описани от дадените индекси.
# getMaxDistance(indices): Изчислява максималното разстояние сред разстоянията на различните маршрути, описани от 
# подадените индекси, след като те бъдат разделени на отделни маршрути.
# getTotalDistance(indices): Изчислява комбинираното разстояние на различните маршрути, описани от дадените индекси.
# plotData(indices): Разделя списъка от индекси на отделни маршрути и ги изобразява на графика, като оцветява всеки 
# маршрут в различен цвят.
# Когато този клас се изпълнява като самостоятелна програма, основният метод на класа използва горепосочените методи, 
# като създава инстанция на VehicleRoutingProblem, като използва основния TSP, зададен на „bayg29“ – същия проблем,
# който използвахме в предишната секция.

# Броят на превозните средства е зададен на 3, а индексът на местоположението на депото е 12 (което съответства
# на град с централно местоположение).

# Следната графика показва местоположенията на градовете (червени точки) и депото (зелено „x“).

# Основният метод след това генерира случайно решение, разделя го на маршрути и изчислява разстоянията, както е
# показано по-долу:

# Случайно решение:
# [27, 23, 7, 18, 30, 14, 19, 3, 16, 2, 26, 9, 24, 22, 15, 17, 28, 11, 21, 12, 8, 4, 5, 13, 25, 6, 0, 29, 10, 1, 20]

# Разбивка на маршрутите:
# [[27, 23, 7, 18], [14, 19, 3, 16, 2, 26, 9, 24, 22, 15, 17, 28, 11, 21, 8, 4, 5, 13, 25, 6, 0], [10, 1, 20]]

# Общо разстояние:
# 26653.845703125

# Максимално разстояние:
# 21517.686

# Обърнете внимание как оригиналният списък от индекси на случайното решение се разделя на отделни маршрути с 
# помощта на индексите-разделители (29 и 30).

# Графиката на това случайно решение е показана по-долу:

# Както бихме очаквали от случайно решение, то е далеч от оптималното. Това става ясно от неефективния ред на градовете
# по дългия (зелен) маршрут, както и от факта, че един маршрут (зелен) е значително по-дълъг от останалите два (червен и лилав).

# В следващата подсекция ще се опитаме да генерираме добри решения, използвайки метода на генетичните алгоритми.

# Решението с генетичен алгоритъм за VRP се намира във файла 04-solve-vrp.py, разположен на връзката.

# Тъй като успяхме да надградим върху решението за TSP и използвахме подобна репрезентация за решението – масив от 
# индекси – можехме да приложим същия генетичен подход, който използвахме в предишната секция. Освен това, успяхме 
# да се възползваме от елитизма, като повторно използвахме елитарната версия, която създадохме за генетичния поток.
# Това прави нашето решение с генетичен алгоритъм много сходно с това, което използвахме за решаване на TSP.


# Следните стъпки описват основните части на нашето решение:

# Програмата започва със създаване на инстанция на класа VehicleRoutingProblem, като използва „bayg29“ TSP за основните 
# данни, задава местоположението на депото като 12 и броя на превозните средства като 3:

# TSP_NAME = "bayg29"
# NUM_OF_VEHICLES = 3
# DEPOT_LOCATION = 12
# vrp = vrp.VehicleRoutingProblem(TSP_NAME, NUM_OF_VEHICLES, DEPOT_LOCATION)

# Функцията за пригодност (fitness function) е настроена да минимизира дължината на най-дългия маршрут сред трите маршрута, 
# генерирани от всяко решение:

# def vrpDistance(individual):
#     return vrp.getMaxDistance(individual),

# toolbox.register("evaluate", vrpDistance)

# За генетичните оператори отново използваме турнирна селекция с размер на турнира 2, която се подпомага от елитистичния
# подход, както и оператори за кръстосване и мутация, които са специализирани за подредени списъци:

# # Генетични оператори:
# toolbox.register("select", tools.selTournament, tournsize=2)
# toolbox.register("mate", tools.cxUniformPartialyMatched, indpb=2.0/len(vrp))
# toolbox.register("mutate", tools.mutShuffleIndexes, indpb=1.0/len(vrp))

# Тъй като VRP е по-труден от TSP, избрахме по-голям размер на популацията и повече поколения в сравнение с предишния случай:

# # Константи за генетичния алгоритъм:
# POPULATION_SIZE = 500
# P_CROSSOVER = 0.9
# P_MUTATION = 0.2
# MAX_GENERATIONS = 1000
# HALL_OF_FAME_SIZE = 30

# И това е всичко! Готови сме да стартираме програмата. Резултатите, които получаваме с тези настройки, са показани тук –
# три маршрута с максимална дължина от 3857:

# -- Най-доброто решение досега = Individual('i', [0, 20, 17, 16, 13, 21, 10,14, 3, 29, 15, 23, 7, 26, 12, 22, 6, 24, 18, 9, 19, 30, 27, 11, 5, 4,8, 25, 2, 28, 1])
# -- Най-добра досега пригодност = 3857.36376953125
# -- Разбивка на маршрутите = [[0, 20, 17, 16, 13, 21, 10, 14, 3], [15, 23, 7,26, 22, 6, 24, 18, 9, 19], [27, 11, 5, 4, 8, 25, 2, 28, 1]]
# -- Обща дължина = 11541.875
# -- Максимална дължина = 3857.3638

# Отново забележете как решението е разделено на три отделни маршрута, като най-високите два индекса (29, 30) се използват
# като разделители и местоположението на депото (12) се игнорира. Получихме три маршрута, два от които обхващат по девет града,
# а третият – десет града.

# Графичното изобразяване на решението води до следната фигура, показваща трите получени маршрута.

# Следната графика със статистически данни показва, че алгоритъмът е извършил по-голямата част от оптимизацията преди 
# достигане на 300 поколения. След това има няколко малки подобрения.

# А какво ще се случи, ако променим броя на превозните средства? Нека стартираме алгоритъма отново, след като увеличим 
# броя на превозните средства на шест, без да правим други промени:

# NUM_OF_VEHICLES = 6

# Резултатите от този експеримент са показани тук – шест маршрута, с максимална дължина от 2803:

# Полученото решение с шест превозни средства включва следното:

# Най-добрият индивид (хромозома):
# [27, 11, 5, 8, 4, 33, 12, 24, 6, 22, 7, 23, 29, 28, 20, 0, 26, 15, 32, 3, 18, 13, 17, 1, 31, 19, 25, 2, 30, 9, 14, 16, 21, 10]

# Най-добра стойност на пригодност (фитнес):
# 2803.584716796875

# Разбивка на маршрутите:

# [[27, 11, 5, 8, 4], 
#  [24, 6, 22, 7, 23], 
#  [28, 20, 0, 26, 15], 
#  [3, 18, 13, 17, 1], 
#  [19, 25, 2], 
#  [9, 14, 16, 21, 10]]

# Общо изминато разстояние:
# 16317.9892578125

# Максимална дължина на маршрут:
# 2803.5847

# В резултат на увеличаването на броя на превозните средства се наблюдава по-равномерно разпределение на маршрутите и
# значително намаление на най-дългия маршрут в сравнение с предходното решение. Това предполага по-ефективно използване
# на наличните ресурси и потенциално по-добро време за доставка.

# Забележете, че удвояването на броя на превозните средства не е довело до пропорционално намаляване на максималното 
# разстояние (2803 при шест превозни средства в сравнение с 3857 при три). Това вероятно се дължи на факта, че всяка 
# отделна маршрута все още трябва да започва и завършва на местоположението на депото, което се добавя към градовете в маршрута.

# Графичното представяне на решението показва шестте резултатни маршрута. Един интересен аспект, който се демонстрира 
# в този график, е че оранжевият маршрут изглежда неоптимизиран. Тъй като генетичният алгоритъм е инструктиран да
# минимизира най-дългия маршрут, всеки маршрут, който е по-кратък от най-дългия, може да не бъде оптимизиран допълнително.

# Препоръчваме ви да модифицирате решението, за да подобрите допълнително маршрутите и да проучите възможности за 
# по-равномерно разпределение на товарите между превозните средства.

# Както и при случая с трите превозни средства, следващата графика със статистики показва, че алгоритъмът е извършил 
# по-голямата част от оптимизацията преди достигане на 200 поколения, след което има няколко малки подобрения.

# Намерeното решение изглежда разумно, но дали можем да постигнем по-добри резултати? Какво ще стане, ако използваме
# различен брой превозни средства? Ами ако изберем различно местоположение за депото? Може би можем да опитаме с
# различни генетични оператори или други параметри на алгоритъма? Дори можем да разгледаме различни критерии за пригодност
# на решенията.

# Насърчаваме ви да експериментирате с всички тези възможности и да извлечете ценни уроци от резултатите на вашите експерименти.

# Обобщение
# В тази глава бяха представени търсещи задачи и комбинаторна оптимизация. След това подробно разгледахме три класически
# комбинаторни задачи – всяка с множество реални приложения – проблема с раницата (knapsack problem), проблема на търговския
# пътник (TSP) и проблема с маршрутизацията на превозни средства (VRP). За всяка от тези задачи следвахме сходен процес, 
# който включваше:

# Намиране на подходящо представяне на решението.
# Създаване на клас, който капсулира проблема и оценява дадено решение.
# Изграждане на генетичен алгоритъм, който използва този клас.
# Успяхме да постигнем валидни решения за трите задачи, като същевременно експериментирахме с картографиране от генотип
# към фенотип и изследване, подкрепено от елитизъм.

# В следващата глава ще се запознаем със семейство от тясно свързани задачи – задачи за удовлетворяване на ограничения 
# (constraint satisfaction problems), започвайки с класическата задача за поставяне на n царици на шахматна дъска.

# Допълнително четене
# За повече информация може да се запознаете със следните ресурси:

# Решаване на проблема с раницата чрез динамично програмиране, от книгата Keras Reinforcement Learning Projects,
# от Джузепе Чабуро, септември 2018 г.
# Проблемът с маршрутизацията на превозни средства, от книгата Keras Reinforcement Learning Projects,
# от Джузепе Чабуро, септември 2018 г.








