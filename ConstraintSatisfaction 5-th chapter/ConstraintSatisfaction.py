#  https://github.com/PacktPublishing/Hands-On-Genetic-Algorithmswith-Python-Second-Edition/tree/main/chapter_05

# Удовлетворяване на ограничения (Constraint Satisfaction)
# В тази глава ще научите как генетичните алгоритми могат да бъдат използвани за решаване на задачи за удовлетворяване на
# ограничения (constraint satisfaction problems). Ще започнем с описание на концепцията за удовлетворяване на ограниченията
# и как тя се прилага към търсещите задачи и комбинаторната оптимизация. След това ще разгледаме няколко практически примера 
# за задачи за удовлетворяване на ограничения и техните решения, базирани на Python с помощта на DEAP. Проблемите, 
# които ще разгледаме, включват добре познатия проблем с N царици (N-Queen problem), следван от проблема с графика на 
# медицинските сестри (nurse scheduling problem) и накрая – проблема с оцветяването на графи (graph coloring problem). 
# По време на този процес ще научим разликата между твърдите (hard) и меките (soft) ограничения, както и как те могат да 
# бъдат включени в процеса на намиране на решение.

# В тази глава ще разгледаме следните теми:

# Разбиране на същността на задачите за удовлетворяване на ограничения
# Решаване на проблема с N царици с помощта на генетичен алгоритъм, имплементиран с DEAP
# Решаване на пример за графика на медицинските сестри с помощта на генетичен алгоритъм, имплементиран с DEAP
# Решаване на проблема с оцветяването на графи с помощта на генетичен алгоритъм, имплементиран с DEAP
# Разбиране на концепциите за твърди и меки ограничения и как да ги приложим при решаване на задачи

# page 118/141

# Удовлетворяване на ограничения в задачи за търсене
# В предходната глава разгледахме решаването на задачи за търсене, които се фокусираха върху методичното оценяване на
# състояния и преходи между тях. Всеки преход между състояния обикновено включва разходи или печалби, а целта на търсенето 
# беше да се минимизират разходите или да се максимизират печалбите. Задачите за удовлетворяване на ограничения
# (constraint satisfaction problems – CSP) представляват вариант на задачите за търсене, при които състоянията трябва да
# отговарят на определени ограничения или лимити. Ако можем да превърнем различните нарушения на ограниченията в разходи и 
# да се стремим към тяхното минимизиране, решаването на задача за удовлетворяване на ограничения може да наподобява решаването 
# на обща задача за търсене.

# Подобно на комбинаторните задачи за оптимизация, задачите за удовлетворяване на ограничения намират важни приложения в 
# области като изкуствения интелект, изследването на операциите и разпознаването на образи. По-доброто разбиране на тези 
# проблеми може да помогне при решаването на много видове задачи, които на пръв поглед може да изглеждат несвързани. 
# Задачите за удовлетворяване на ограничения често притежават висока сложност, което прави генетичните алгоритми подходящ 
# метод за тяхното решаване.

# Проблемът с N царици, който ще бъде представен в следващата секция, илюстрира концепцията за удовлетворяване на ограничения 
# и демонстрира как такива задачи могат да бъдат решени по много сходен начин с проблемите, които 
# разгледахме в предходната глава.


# Решаване на задачата N-царици
# Първоначално известен като пъзелът с осемте царици, класическият проблем N-царици произлиза от играта шах, като първоначално 
# се е разглеждал върху стандартната шахматна дъска 8×8. Целта на задачата е да се разположат осем шахматни царици върху дъската
# така, че нито две от тях да не се заплашват взаимно. С други думи, нито две царици не трябва да се намират в една и съща
# редица, колона или диагонал. Задачата N-царици обобщава този проблем, като използва дъска с размер N×N и N шахматни царици.

# Известно е, че задачата има решение за всяко естествено число n, с изключение на случаите n=2 и n=3. За първоначалния случай
# с осем царици съществуват 92 решения или 12 уникални решения, ако се считат симетричните решения за идентични. Едно от 
# решенията изглежда по следния начин:

# Ако приложим комбинаторика, броят на всички възможни начини за разполагане на осем фигури върху дъската 8×8 е 4,426,165,368 
# комбинации. Въпреки това, ако успеем да създаваме кандидат-решения по начин, който гарантира, че нито две царици ще бъдат 
# поставени в една и съща редица или колона, броят на възможните комбинации драстично намалява до 8! (факториел на 8), което
# възлиза на 40,320.

# Ще се възползваме от тази идея в следващата подсекция, когато изберем начина, по който нашето решение на този проблем ще 
# бъде представено.

# Представяне на решението
# Когато решаваме задачата N-царици, можем да се възползваме от знанието, че във всеки ред ще се намира точно една царица и
# че нито две царици ще споделят една и съща колона. Това означава, че можем да представим всяко кандидат-решение като подреден
# списък от цели числа – или списък от индекси, като всеки индекс представлява колоната, в която е поставена царицата за 
# съответния ред.

# Например, за задача с четири царици върху шахматна дъска 4×4, можем да използваме следния списък от индекси:
# [3, 2, 0, 1]

# Това се превежда в следните позиции:

# В първия ред царицата е поставена на позиция 3 (четвърта колона).
# Във втория ред царицата е поставена на позиция 2 (трета колона).
# В третия ред царицата е поставена на позиция 0 (първа колона).
# В четвъртия ред царицата е поставена на позиция 1 (втора колона).
# Това е изобразено на следната фигура:

# По подобен начин, друго разпределение на индексите може да изглежда по следния начин:
# [1, 3, 0, 2]

# Това разпределение представлява кандидат-решението, показано на следващата фигура. Единствените възможни нарушения на
# ограниченията в кандидат-решенията, представени по този начин, са споделени диагонали между двойки царици.

# Например, първото кандидат-решение, което обсъдихме, съдържа две нарушения, както е показано тук. Въпреки това, предходното 
# разпределение не съдържаше нарушения.

# Това означава, че при оценяване на решенията, представени по този начин, е необходимо само да се намерят и преброят
# споделените диагонали между позициите, които те заемат.

# Решението на проблема, което току-що обсъдихме, е централен елемент от Python класа, който ще опишем в следващата подточка.

# page 122/145







