#  https://github.com/PacktPublishing/Hands-On-Genetic-Algorithmswith-Python-Second-Edition/tree/main/chapter_05

# Удовлетворяване на ограничения (Constraint Satisfaction)
# В тази глава ще научите как генетичните алгоритми могат да бъдат използвани за решаване на задачи за удовлетворяване на
# ограничения (constraint satisfaction problems). Ще започнем с описание на концепцията за удовлетворяване на ограниченията
# и как тя се прилага към търсещите задачи и комбинаторната оптимизация. След това ще разгледаме няколко практически примера 
# за задачи за удовлетворяване на ограничения и техните решения, базирани на Python с помощта на DEAP. Проблемите, 
# които ще разгледаме, включват добре познатия проблем с N царици (N-Queen problem), следван от проблема с графика на 
# медицинските сестри (nurse scheduling problem) и накрая – проблема с оцветяването на графи (graph coloring problem). 
# По време на този процес ще научим разликата между твърдите (hard) и меките (soft) ограничения, както и как те могат да 
# бъдат включени в процеса на намиране на решение.

# В тази глава ще разгледаме следните теми:

# Разбиране на същността на задачите за удовлетворяване на ограничения
# Решаване на проблема с N царици с помощта на генетичен алгоритъм, имплементиран с DEAP
# Решаване на пример за графика на медицинските сестри с помощта на генетичен алгоритъм, имплементиран с DEAP
# Решаване на проблема с оцветяването на графи с помощта на генетичен алгоритъм, имплементиран с DEAP
# Разбиране на концепциите за твърди и меки ограничения и как да ги приложим при решаване на задачи

# page 118/141

# Удовлетворяване на ограничения в задачи за търсене
# В предходната глава разгледахме решаването на задачи за търсене, които се фокусираха върху методичното оценяване на
# състояния и преходи между тях. Всеки преход между състояния обикновено включва разходи или печалби, а целта на търсенето 
# беше да се минимизират разходите или да се максимизират печалбите. Задачите за удовлетворяване на ограничения
# (constraint satisfaction problems – CSP) представляват вариант на задачите за търсене, при които състоянията трябва да
# отговарят на определени ограничения или лимити. Ако можем да превърнем различните нарушения на ограниченията в разходи и 
# да се стремим към тяхното минимизиране, решаването на задача за удовлетворяване на ограничения може да наподобява решаването 
# на обща задача за търсене.

# Подобно на комбинаторните задачи за оптимизация, задачите за удовлетворяване на ограничения намират важни приложения в 
# области като изкуствения интелект, изследването на операциите и разпознаването на образи. По-доброто разбиране на тези 
# проблеми може да помогне при решаването на много видове задачи, които на пръв поглед може да изглеждат несвързани. 
# Задачите за удовлетворяване на ограничения често притежават висока сложност, което прави генетичните алгоритми подходящ 
# метод за тяхното решаване.

# Проблемът с N царици, който ще бъде представен в следващата секция, илюстрира концепцията за удовлетворяване на ограничения 
# и демонстрира как такива задачи могат да бъдат решени по много сходен начин с проблемите, които 
# разгледахме в предходната глава.


# Решаване на задачата N-царици
# Първоначално известен като пъзелът с осемте царици, класическият проблем N-царици произлиза от играта шах, като първоначално 
# се е разглеждал върху стандартната шахматна дъска 8×8. Целта на задачата е да се разположат осем шахматни царици върху дъската
# така, че нито две от тях да не се заплашват взаимно. С други думи, нито две царици не трябва да се намират в една и съща
# редица, колона или диагонал. Задачата N-царици обобщава този проблем, като използва дъска с размер N×N и N шахматни царици.

# Известно е, че задачата има решение за всяко естествено число n, с изключение на случаите n=2 и n=3. За първоначалния случай
# с осем царици съществуват 92 решения или 12 уникални решения, ако се считат симетричните решения за идентични. Едно от 
# решенията изглежда по следния начин:

# Ако приложим комбинаторика, броят на всички възможни начини за разполагане на осем фигури върху дъската 8×8 е 4,426,165,368 
# комбинации. Въпреки това, ако успеем да създаваме кандидат-решения по начин, който гарантира, че нито две царици ще бъдат 
# поставени в една и съща редица или колона, броят на възможните комбинации драстично намалява до 8! (факториел на 8), което
# възлиза на 40,320.

# Ще се възползваме от тази идея в следващата подсекция, когато изберем начина, по който нашето решение на този проблем ще 
# бъде представено.

# Представяне на решението
# Когато решаваме задачата N-царици, можем да се възползваме от знанието, че във всеки ред ще се намира точно една царица и
# че нито две царици ще споделят една и съща колона. Това означава, че можем да представим всяко кандидат-решение като подреден
# списък от цели числа – или списък от индекси, като всеки индекс представлява колоната, в която е поставена царицата за 
# съответния ред.

# Например, за задача с четири царици върху шахматна дъска 4×4, можем да използваме следния списък от индекси:
# [3, 2, 0, 1]

# Това се превежда в следните позиции:

# В първия ред царицата е поставена на позиция 3 (четвърта колона).
# Във втория ред царицата е поставена на позиция 2 (трета колона).
# В третия ред царицата е поставена на позиция 0 (първа колона).
# В четвъртия ред царицата е поставена на позиция 1 (втора колона).
# Това е изобразено на следната фигура:

# По подобен начин, друго разпределение на индексите може да изглежда по следния начин:
# [1, 3, 0, 2]

# Това разпределение представлява кандидат-решението, показано на следващата фигура. Единствените възможни нарушения на
# ограниченията в кандидат-решенията, представени по този начин, са споделени диагонали между двойки царици.

# Например, първото кандидат-решение, което обсъдихме, съдържа две нарушения, както е показано тук. Въпреки това, предходното 
# разпределение не съдържаше нарушения.

# Това означава, че при оценяване на решенията, представени по този начин, е необходимо само да се намерят и преброят
# споделените диагонали между позициите, които те заемат.

# Решението на проблема, което току-що обсъдихме, е централен елемент от Python класа, който ще опишем в следващата подточка.

# page 122/145

# За да обхванем проблема N-Queens, създадохме Python клас, наречен NQueensProblem. Този клас може да бъде намерен във файла
# queens.py в GitHub хранилището на тази книга:
# https://github.com/PacktPublishing/Hands-On-Genetic-Algorithms-with-Python-Second-Edition/blob/main/chapter_05/queens.py

# Класът се инициализира с желания размер на проблема и предоставя следните публични методи:

# getViolationsCount(positions): Изчислява броя на нарушенията в даденото решение, което е представено чрез списък от индекси,
# както беше обсъдено в предишната подточка.
# plotBoard(positions): Начертава позициите на цариците върху дъската според даденото решение.
# Главният метод на класа използва тези методи, като създава задача за осем царици и тества следното кандидат-решение:
# [1, 2, 7, 5, 0, 3, 4, 6]

# След това решението се начертава и се изчислява броят на нарушенията на ограниченията. Полученият изход е следният:
# Number of violations = 3

# Решение с генетични алгоритми
# За да решим проблема N-Queens с помощта на генетичен алгоритъм, създадохме Python програма, наречена 01-solve-n-queens.py,
# която се намира на:
# https://github.com/PacktPublishing/Hands-On-Genetic-Algorithms-with-Python-Second-Edition/blob/main/chapter_05/01_solve_n_queens.py.

# Тъй като избраната от нас репрезентация за решението на този проблем е списък (или масив) от индекси, която е подобна на
# репрезентацията, използвана за проблема на търговския пътник (TSP) и проблема с маршрутизацията на превозни средства (VRP) в
# Глава 4: Комбинаторна оптимизация, можем да приложим подобен генетичен подход като използвания там. Освен това, отново ще
# използваме елитизъм, като преизползваме създадената от нас подобрена версия на простия генетичен поток в DEAP.

# Следващите стъпки описват основните части на нашето решение:

# Създаване на инстанция на класа NQueensProblem, използвайки желания размер на проблема:

# nQueens = queens.NQueensProblem(NUM_OF_QUEENS)

# Дефиниране на стратегия за фитнес, като целта ни е да минимизираме броя на нарушенията (надяваме се до стойност 0), 
# затова използваме единична цел с минимизиращ подход:

# creator.create("FitnessMin", base.Fitness, weights=(-1.0,))

# Тъй като решението е представено като подреден списък от цели числа, където всяко число обозначава позицията на царицата в
# колоната, можем да използваме следните дефиниции на toolbox, за да създадем началната популация:

# # създаване на оператор, който генерира произволно разбъркани индекси:
# toolbox.register("randomOrder", random.sample, \
# range(len(nQueens)), len(nQueens))

# toolbox.register("individualCreator", tools.initIterate, \
# creator.Individual, toolbox.randomOrder)

# toolbox.register("populationCreator", tools.initRepeat, \
# list, toolbox.individualCreator)

# Функцията за фитнес се настройва да брои броя на нарушенията, причинени от позиционирането на цариците върху шахматната 
# дъска, както е представено във всяко решение:

# def getViolationsCount(individual):
#     return nQueens.getViolationsCount(individual),

# toolbox.register("evaluate", getViolationsCount)

# Що се отнася до генетичните оператори, използваме турнирна селекция с размер на турнира 2, както и оператори за кръстосване
# и мутация, които са специализирани за подредени списъци:

# # Генетични оператори:
# toolbox.register("select", tools.selTournament, \
# tournsize=2)

# toolbox.register("mate", tools.cxUniformPartialyMatched, \
# indpb=2.0/len(nQueens))

# toolbox.register("mutate", tools.mutShuffleIndexes, \
# indpb=1.0/len(nQueens))

# Освен това, продължаваме да използваме подхода на елитизъм, при който членовете на „залата на славата“ (HOF) – най-добрите
# текущи индивиди – винаги се предават непроменени в следващото поколение. Както установихме в предишната глава, този 
# подход работи добре с турнирна селекция с размер 2:

# population, logbook = elitism.eaSimpleWithElitism(
#     population,
#     toolbox,
#     cxpb=P_CROSSOVER,
#     mutpb=P_MUTATION,
#     ngen=MAX_GENERATIONS,
#     stats=stats,
#     halloffame=hof,
#     verbose=True
# )


# Тъй като всяка задача N-Queens може да има множество възможни решения, извеждаме всички членове на HOF, вместо само 
# най-добрия, за да видим колко валидни решения сме намерили:

# print("- Best solutions are:")
# for i in range(HALL_OF_FAME_SIZE):
#     print(i, ": ", hof.items[i].fitness.values[0], " -> ", hof.items[i])

# Както видяхме по-рано, представянето на решението ни намалява случая с осем царици до около 40 000 възможни комбинации,
# което го прави сравнително малък проблем. За да направим нещата по-интересни, нека увеличим размера до 16 царици, където
# броят на възможните кандидат решения ще бъде 16!. Това се изчислява до колосалната стойност от 20,922,789,888,000. 
# Броят на валидните решения на този проблем също е доста голям – малко под 15 милиона. Въпреки това, в сравнение с броя
# на възможните комбинации, намирането на валидно решение все още е като търсене на игла в купа сено.

# Преди да стартираме програмата, нека зададем следните константи за алгоритъма:

# NUM_OF_QUEENS = 16
# POPULATION_SIZE = 300
# MAX_GENERATIONS = 100
# HALL_OF_FAME_SIZE = 30
# P_CROSSOVER = 0.9
# P_MUTATION = 0.1

# Стартирането на програмата с тези настройки дава следния изход:

# gen nevals min avg
# 0 300 3 10.4533
# 1 246 3 8.85333
# ..
# 23 250 1 4.38
# 24 227 0 4.32
# ..
# - Best solutions are:
# 0 : 0.0 -> Individual('i', [7, 2, 8, 14, 9, 4, 0, 15, 6, 11, 13, 1, 3, 5, 10, 12])
# 1 : 0.0 -> Individual('i', [7, 2, 6, 14, 9, 4, 0, 15, 8, 11, 13, 1, 3, 5, 12, 10])
# ..
# 7 : 0.0 -> Individual('i', [14, 2, 6, 12, 7, 4, 0, 15, 8, 11, 3, 1, 9, 5, 10, 13])
# 8 : 1.0 -> Individual('i', [2, 13, 6, 12, 7, 4, 0, 15, 8, 14, 3, 1, 9, 5, 10, 11])
# ..

# Тези резултати показват, че сме успели да намерим няколко решения без нарушения (фитнес стойност 0), а други 
# решения имат само една грешка.

# От разпечатките можем да видим, че решение е било намерено за първи път в поколение 24, където стойността на пригодност 
# (fitness) е показана като 0, което означава липса на нарушения. Освен това, разпечатката на най-добрите решения показва,
# че осем различни решения са намерени по време на изпълнението. Тези решения са записите от 0 до 7 в HOF, всички от които
# имат стойност на пригодност 0. Следващият запис вече има стойност на пригодност 1, което означава едно нарушение.

# Първата графика, която е създадена от програмата, изобразява разположението на 16-те царици върху шахматната дъска с
# размери 16x16, както е определено от първото намерено валидно решение – [7, 2, 8, 14, 9, 4, 0, 15, 6, 11, 13, 1, 3, 5, 10, 12].

# Втората графика съдържа диаграма на максималните и средните стойности на пригодност през поколенията. От тази графика
# можем да видим, че въпреки че най-добрата стойност на пригодност от нула е била намерена рано – около поколение 24 – средната
# стойност на пригодността е продължила да намалява, докато са били намирани още решения.

# Увеличаването на стойността на MAX_GENERATIONS до 400, без да се правят други промени, ще доведе до намирането на 38
# валидни решения. Ако увеличим MAX_GENERATIONS до 500, всички 50 члена на HOF ще съдържат валидни решения. Насърчаваме
# ви да изпробвате различни комбинации от настройките на генетичния алгоритъм, както и да решавате други размери на 
# задачата N-Queen.

# В следващия раздел ще преминем от подреждане на фигури върху дъска към разпределяне на работници в работен график.

# page 127/150