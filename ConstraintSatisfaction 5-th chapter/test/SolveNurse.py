# Решаване на проблема с графика на медицинските сестри
# Представете си, че сте отговорни за планирането на смените на медицинските сестри във вашето болнично отделение за тази 
# седмица. Има три смени на ден – сутрешна, следобедна и нощна – и за всяка смяна трябва да назначите една или повече от
# осемте медицински сестри, които работят във вашето отделение. Ако това ви се струва лесна задача, погледнете списъка с 
# приложимите болнични правила:

# Медицинска сестра няма право да работи две последователни смени
# Медицинска сестра няма право да работи повече от пет смени седмично
# Броят на медицинските сестри на смяна във вашето отделение трябва да попада в следните граници:
# Сутрешна смяна: 2-3 медицински сестри
# Следобедна смяна: 2-4 медицински сестри
# Нощна смяна: 1-2 медицински сестри

# Освен това, всяка медицинска сестра може да има предпочитания за смени. Например, една сестра предпочита да работи само 
# сутрешни смени, друга не желае да работи следобедни смени и т.н.

# Тази задача е пример за проблема с графика на медицинските сестри (NSP), който може да има много варианти. Възможните 
# вариации могат да включват различни специализации за различните медицински сестри, възможност за работа на допълнителни 
# смени (извънреден труд), или дори различни видове смени – като 8-часови и 12-часови смени.

# На този етап вероятно изглежда добра идея да напишем програма, която да съставя графика вместо вас. Защо да не приложим
# нашите знания за генетични алгоритми, за да реализираме такава програма? Както обикновено, ще започнем с представянето на
# решението на проблема.

# Представяне на решението
# За да решим проблема с графика на медицинските сестри, решихме да използваме двоичен списък (или масив) за представяне на 
# графика, тъй като това ще бъде интуитивно за нас и вече знаем, че генетичните алгоритми могат естествено да обработват този
# тип представяне.

# За всяка медицинска сестра можем да използваме двоична последователност, представляваща 21-те смени за седмицата. Стойност
# 1 представлява смяна, на която сестрата е насрочена да работи. Например, разгледайте следния двоичен списък:

# [0, 1, 0, 1, 0, 1, 0, 1, 1, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, 0]
# Този списък може да бъде разделен на следните групи от три стойности, представляващи смените на тази медицинска сестра за 
# всеки ден от седмицата:

# Неделя	Понеделник	Вторник	Сряда	Четвъртък	Петък	Събота
# [0, 1, 0]	[1, 0, 1]	[0, 1, 1]	[0, 0, 0]	[0, 0, 1]	[1, 0, 0]	[0, 1, 0]
# Следобед	Сутрин и нощ	Следобед и нощ	Няма	Нощ	Сутрин	Следобед
# Таблица 5.1: Преобразуване на двоичната последователност в дневни смени

# Графиците на всички медицински сестри могат да бъдат обединени в една дълга двоична последователност, представляваща цялото
# решение.

# При оценка на решението, тази дълга последователност може да бъде разделена на индивидуални графици за всяка медицинска 
# сестра, като се проверява за нарушения на ограниченията. Например, в горепосочения график за медицинската сестра има две 
# последователни смени, които се нарушават – следобедна смяна, следвана от нощна, и нощна смяна, следвана от сутрешна.

# Броят на седмичните смени за същата сестра може лесно да се изчисли, като се съберат всички стойности 1 в списъка, което 
# в този случай води до общо 8 смени.

# Също така, можем лесно да проверим спазването на предпочитаните смени, като сравним дневните смени с предварително зададените
# предпочитани смени на съответната медицинска сестра.

# Твърди ограничения срещу меки ограничения
# При решаване на проблема с графика на медицинските сестри трябва да имаме предвид, че някои от ограниченията представляват
# болнични правила, които не могат да бъдат нарушени. График, който съдържа едно или повече нарушения на тези правила, се 
# счита за невалиден. По-общо казано, тези правила са известни като твърди ограничения.

# От друга страна, предпочитанията на медицинските сестри могат да бъдат разглеждани като меки ограничения. Желателно е да
# се спазват възможно най-много, и решение, което съдържа малко или никакви нарушения на тези ограничения, се счита за
# по-добро от такова, което съдържа повече нарушения. Въпреки това, нарушение на тези ограничения не прави решението невалидно.

# В случая с проблема N-Queens, всички ограничения – за ред, колона и диагонал – бяха твърди ограничения. Ако не намерим решение,
# при което броят на нарушенията е нула, няма да имаме валидно решение на проблема. Тук, от друга страна, търсим решение, 
# което няма да нарушава болничните правила, като същевременно минимизира броя на нарушенията спрямо предпочитанията на 
# медицинските сестри.

# Докато справянето с меките ограничения е подобно на всяка друга оптимизационна задача – тоест, стремим се да ги минимизираме 
# – как можем да се справим с твърдите ограничения, които ги съпътстват? Съществуват няколко възможни стратегии:

# Намиране на конкретно представяне (кодиране) на решението, което елиминира възможността за нарушение на твърдите ограничения.
# Например, когато решавахме проблема N-Queens, успяхме да представим решението по начин, който елиминира възможността за две
# от трите ограничения – ред и колона – което значително опрости решението ни. Въпреки това, намирането на такова кодиране може
# да бъде трудно.

# Отхвърляне на кандидат-решения, които нарушават твърдо ограничение, при тяхната оценка. Недостатъкът на този подход е загубата
# на информация, съдържаща се в тези решения, която може да бъде ценна за решението на проблема. Това може значително да забави 
# оптимизационния процес.

# Поправка на кандидат-решения, които нарушават твърди ограничения, при тяхната оценка. С други думи, намиране на начин за 
# манипулиране и модифициране на решението, така че вече да не нарушава ограниченията. Създаването на такава процедура за
# поправка може да се окаже трудно или невъзможно за повечето проблеми, а също така процесът на поправка може да доведе до
# значителна загуба на информация.

# При оценяване на решенията, наказване на кандидат-решения, които нарушават твърди ограничения. Това ще понижи оценката на 
# решението и ще го направи по-малко желано, но няма да го елиминира напълно, така че информацията, съдържаща се в него,
# няма да бъде загубена. На практика това води до разглеждане на твърдото ограничение като меко, но с по-голямо наказание.
# Основното предизвикателство при този метод е намирането на подходящата степен на наказание. Твърде строго наказание може 
# да доведе до фактическо елиминиране на такива решения, докато прекалено слабо наказание може да доведе до това, че тези 
# решения да се окажат оптимални.
# В нашия случай избрахме да приложим четвъртия подход и да налагаме по-големи наказания за нарушенията на твърдите ограничения,
# отколкото за меките. Това направихме чрез създаването на функция на разходите, при която цената на нарушаването на твърдо 
# ограничение е по-голяма от тази на меко ограничение. Общата стойност на разходите след това се използва като фитнес функция,
# която трябва да бъде минимизирана. Това е реализирано в рамките на представянето на проблема, което ще бъде обсъдено в 
# следващия подраздел.

# Python представяне на проблема

# За да обхванем проблема с разпределението на графика на медицинските сестри, който описахме в началото на тази секция,
# създадохме Python клас, наречен NurseSchedulingProblem. Този клас се намира във файла nurses.py, който може да бъде намерен 
# на следния адрес:
# https://github.com/PacktPublishing/Hands-On-Genetic-Algorithms-with-Python-Second-Edition/blob/main/chapter_05/nurses.py.

# Конструкторът на класа приема параметъра hardConstraintPenalty, който представлява коефициента на наказание за нарушение на 
# твърдо ограничение (докато наказанието за нарушение на меко ограничение е фиксирано на 1). След това конструкторът продължава
# с инициализирането на различните параметри, описващи проблема с графика:

# # списък на медицинските сестри:
# self.nurses = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H']

# # предпочитанията на медицинските сестри по смени - сутрин, следобед, нощ:
# self.shiftPreference = [[1, 0, 0], [1, 1, 0], [0, 1, 1], [0, 1, 0],
#                         [0, 0, 1], [1, 1, 1], [0, 1, 1], [1, 1, 1]]

# # минимален и максимален брой на сестрите, позволени за всяка смяна - сутрин, следобед, нощ:
# self.shiftMin = [2, 2, 1]
# self.shiftMax = [3, 4, 2]

# # максимален брой смени на седмица, позволени за всяка сестра:
# self.maxShiftsPerWeek = 5

# Класът използва следния метод за преобразуване на даден график в речник със самостоятелен график за всяка медицинска сестра:

# getNurseShifts(schedule)


# Представяне на проблема с Python
# Следните методи се използват за преброяване на различните видове нарушения:

# countConsecutiveShiftViolations(nurseShiftsDict)
# countShiftsPerWeekViolations(nurseShiftsDict)
# countNursesPerShiftViolations(nurseShiftsDict)
# countShiftPreferenceViolations(nurseShiftsDict)
# Освен това, класът предоставя следните публични методи:

# getCost(schedule): Изчислява общата цена на различните нарушения в дадения график. Този метод използва стойността на
# променливата hardConstraintPenalty.
# printScheduleInfo(schedule): Отпечатва графика и детайлите за нарушенията.
# Основният метод на класа демонстрира неговите методи чрез създаване на инстанция на проблема с графика на медицинските
# сестри и тестване на произволно генерирано решение. Полученият изход може да изглежда по следния начин, когато стойността
# на hardConstraintPenalty е зададена на 10:

# Произволно решение =
# [0 1 0 0 0 1 0 0 0 1 0 0 0 0 1 0 1 1 1 0 1 0 1 1 1 1 1 1 1 1 0 0 1 1 1
# 0 1 0 0 0 0 0 1 1 1 1 1 0 1 1 0 1 0 1 0 1 1 0 0 0 0 0 0 0 0 1 1 0 1 1
# 1 1 0 1 0 1 1 1 0 1 0 1 0 1 0 0 1 0 1 1 1 1 1 1 1 1 1 1 1 0 0 1 1 1 1
# 1 1 1 1 0 1 0 1 1 0 1 0 1 1 0 1 0 1 0 0 1 1 0 1 1 1 0 0 0 0 0 0 0 0 0
# 1 0 1 1 1 0 0 0 0 1 0 0 0 0 0 1 0 1 0 1 0 0 1 1 1 0 1 0]

# Обобщена информация за нарушенията:

# A : [0 1 0 0 0 1 0 0 0 1 0 0 0 0 1 0 1 1 1 0 1]  
# B : [0 1 1 1 1 1 1 1 1 0 0 1 1 1 0 1 0 0 0 0 0]  
# C : [1 1 1 1 1 0 1 1 0 1 0 1 0 1 1 0 0 0 0 0 0]  
# D : [0 0 1 1 0 1 1 1 1 0 1 0 1 1 1 0 1 0 1 0 1]  
# E : [0 0 1 0 1 1 1 1 1 1 1 1 1 1 1 0 0 1 1 1 1]  
# F : [1 1 1 1 0 1 0 1 1 0 1 0 1 1 0 1 0 1 0 0 1]  
# G : [1 0 1 1 1 0 0 0 0 0 0 0 0 0 1 0 1 1 1 0 0]  
# H : [0 0 1 0 0 0 0 0 1 0 1 0 1 0 0 1 1 1 0 1 0]  


# Нарушения на последователни смени = 47  
# Седмични смени = [8, 12, 11, 13, 16, 13, 8, 8]  
# Нарушения на смените на седмица = 49  
# Медицински сестри на смяна = [3, 4, 7, 5, 4, 5, 4, 5, 5, 3, 4, 3, 5, 5, 5, 3, 4, 5, 4, 2, 4]  
# Нарушения на броя на сестрите на смяна = 28  
# Нарушения на предпочитанията за смени = 39  
# Обща цена = 1279  

# Както се вижда от тези резултати, произволно генерираното решение вероятно ще доведе до голям брой нарушения и съответно
# висока стойност на разходите. В следващата подсекция ще се опитаме да минимизираме разходите и да елиминираме всички 
# нарушения на твърдите ограничения, използвайки решение, базирано на генетичен алгоритъм.

# Решение с генетични алгоритми
# За да решим проблема с графика на медицинските сестри, използвайки генетичен алгоритъм, създадохме Python програма, наречена 
# 02-solve-nurses.py, която може да бъде намерена на:

# https://github.com/PacktPublishing/Hands-On-Genetic-Algorithms-with-Python-Second-Edition/blob/main/chapter_05/02_solve_nurses.py

# Тъй като представянето на решението, което избрахме за този проблем, е списък (или масив) от двоични стойности, успяхме да
# използваме същия генетичен подход, който прилагахме и за няколко други проблема, които вече сме решили, като например
# проблема с раницата 0-1, описан в Глава 4: Комбинаторна оптимизация.

# Основните части на нашето решение са описани в следните стъпки:

# Инициализация на проблема
# Програмата започва със създаване на инстанция на класа NurseSchedulingProblem със зададена стойност на наказанието за твърдите
# ограничения (hardConstraintPenalty), което се определя чрез константата HARD_CONSTRAINT_PENALTY:

# nsp = nurses.NurseSchedulingProblem(HARD_CONSTRAINT_PENALTY)

# Дефиниране на стратегията за пригодност
# Тъй като целта ни е да минимизираме разходите, трябва да дефинираме стратегия за пригодност с единична цел за минимизиране:

# creator.create("FitnessMin", base.Fitness, weights=(-1.0,))

# Създаване на първоначалната популация
# Тъй като решението е представено чрез списък от стойности 0 или 1, трябва да използваме следните дефиниции в toolbox, 
# за да създадем първоначалната популация:

# creator.create("Individual", list, fitness=creator.FitnessMin)
# toolbox.register("zeroOrOne", random.randint, 0, 1)
# toolbox.register("individualCreator", tools.initRepeat, \
#                  creator.Individual, toolbox.zeroOrOne, len(nsp))
# toolbox.register("populationCreator", tools.initRepeat, \
#                  list, toolbox.individualCreator)

# Функция за пригодност
# Действителната функция за пригодност е настроена така, че да изчислява разходите за различните нарушения в графика,
# представен от всяко решение:

# def getCost(individual):
#     return nsp.getCost(individual),

# toolbox.register("evaluate", getCost)

# Дефиниране на генетичните оператори
# За генетичните оператори трябва да използваме турнирна селекция с размер на турнира 2, както и двуточково кръстосване и 
# флип-бит мутация, тъй като те са подходящи за двоични списъци:

# toolbox.register("select", tools.selTournament, tournsize=2)
# toolbox.register("mate", tools.cxTwoPoint)
# toolbox.register("mutate", tools.mutFlipBit, indpb=1.0/len(nsp))

# Тези настройки ни позволяват да създадем ефективен генетичен алгоритъм за оптимизиране на графика на медицинските сестри, 
# като се стремим да минимизираме общите разходи и да сведем до минимум нарушенията на твърдите и меките ограничения.

# Продължаваме да използваме елитарния подход, при който членовете на HOF – най-добрите текущи индивиди – винаги се предават
# непроменени в следващото поколение:

# population, logbook = elitism.eaSimpleWithElitism(
#     population, toolbox, cxpb=P_CROSSOVER, 
#     mutpb=P_MUTATION, ngen=MAX_GENERATIONS, 
#     stats=stats, halloffame=hof, verbose=True)

# Когато алгоритъмът приключи, отпечатваме подробностите за най-доброто намерено решение:

# nsp.printScheduleInfo(best)

# Преди да стартираме програмата, нека зададем константите на алгоритъма по следния начин:

# POPULATION_SIZE = 300
# P_CROSSOVER = 0.9
# P_MUTATION = 0.1
# MAX_GENERATIONS = 200
# HALL_OF_FAME_SIZE = 30

# Допълнително, ще започнем, като зададем наказанието за нарушаване на твърдите ограничения на стойност 1, което прави 
# разходите за нарушаване на твърдо ограничение подобни на тези за нарушаване на меко ограничение:

# HARD_CONSTRAINT_PENALTY = 1

# Резултати от изпълнението на програмата с тези настройки изглеждат по следния начин:

# -- Best Fitness = 3.0
# -- Schedule =
# Schedule for each nurse:
# A : [0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0]
# B : [1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0]
# C : [0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0]
# D : [0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0]
# E : [0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0]
# F : [0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0]
# G : [0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 1]
# H : [1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0]

# Резултати за нарушенията:

# consecutive shift violations = 0
# weekly Shifts = [5, 6, 2, 5, 4, 5, 5, 5]
# Shifts Per Week Violations = 1
# Nurses Per Shift = [2, 2, 1, 2, 2, 1, 2, 2, 1, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 1]
# Nurses Per Shift Violations = 0
# Shift Preference Violations = 2

# Това може да изглежда като добър резултат, тъй като завършихме само с три нарушения на ограниченията. Въпреки това, едно
# от тях е нарушение на ограниченията за смени на седмица – медицинска сестра B е насрочена за шест смени през седмицата, 
# което надвишава максимално позволените пет. Това е достатъчно, за да направи цялото решение неприемливо.

# В опит да елиминираме този вид нарушение, ще увеличим стойността на наказанието за твърдите ограничения на 10:

# HARD_CONSTRAINT_PENALTY = 10

# Сега резултатът е следният:

# -- Best Fitness = 3.0
# -- Schedule =
# График за всяка сестра:
# A : [0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0]
# B : [1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0]
# C : [0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1]
# D : [0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0]
# E : [0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0]
# F : [0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0]
# G : [0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0]
# H : [1, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0]

# Резултати за нарушенията:

# consecutive shift violations = 0
# weekly Shifts = [4, 5, 5, 5, 3, 5, 5, 5]
# Shifts Per Week Violations = 0
# Nurses Per Shift = [2, 2, 1, 2, 2, 1, 2, 2, 2, 2, 2, 1, 2, 2, 1, 2, 2, 2, 2, 2, 1]
# Nurses Per Shift Violations = 0
# Shift Preference Violations = 3

# Отново получихме три нарушения, но този път те са само нарушения на меките ограничения, което прави това решение валидно.

# Следната графика, която показва минималната и средната приспособеност (fitness) през поколенията, показва, че през
# първите 40-50 поколения алгоритъмът е успял да елиминира всички нарушения на твърдите ограничения, а след това са се
# случвали само малки постепенни подобрения, когато е било премахнато още едно меко ограничение.