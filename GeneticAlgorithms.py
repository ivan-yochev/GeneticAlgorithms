# Hands-On  Genetic Algorithms with Python by  Eyal Wirsansky

# What are genetic algorithms?
# Genetic algorithms are a family of search algorithms that are inspired by the principles of evolution in 
# nature. By imitating the process of natural selection and reproduction, genetic algorithms can produce 
# high-quality solutions for various problems involving search, optimization, and learning. At the same 
# time, their analogy to natural evolution allows genetic algorithms to overcome some of the hurdles 
# that are encountered by traditional search and optimization algorithms, especially for problems with 
# a large number of parameters and complex mathematical representations.

# The principle of variation: The traits (attributes) of individual specimens belonging to a 
# population may vary. As a result, the specimens differ from each other to some degree, for 
# example, in their behavior or appearance.
#  • The principle of inheritance: Some traits are consistently passed on from specimens to their 
# offspring. As a result, offspring resemble their parents more than they resemble unrelated specimens.
#  • The principle of selection: Populations typically struggle for resources within their given 
# environment. The specimens possessing traits that are better adapted to the environment will 
# be more successful at surviving and will also contribute more offspring to the next generation.

# Генетичните алгоритми поддържат набор от решения за даден пробле, наречен individuals. Тези кандидати се оценявят 
# итеративно и най-добрите от тях се избират за създаване на следващо решение.

# Genotype - Генотип
#  В природата размножаването, размножаването и мутацията се улесняват чрез генотипа – колекция от гени 
# които са групирани в хромозоми. Ако два екземпляра се размножават, за да създадат потомство, всяка хромозома от 
# потомството ще носи комбинация от гени и от двамата родители. Имитиране на тази концепция, в случай на генетични 
# алгоритми, всеки индивид е представен от хромозома, представляваща колекция от гени. За 
# Например, една хромозома може да бъде изразена като двоичен низ, където всеки бит представлява един ген

# Genotype
#  In nature, breeding, reproduction, and mutation are facilitated via the genotype – a collection of genes 
# that are grouped into chromosomes. If two specimens breed to create offspring, each chromosome of 
# the offspring will carry a mix of genes from both parents. Mimicking this concept, in the case of genetic 
# algorithms, each individual is represented by a chromosome representing a collection of genes. For 
# example, a chromosome can be expressed as a binary string, where each bit represents a single gene:

# Population
#  At any point in time, genetic algorithms maintain a population of individuals – a collection of candidate 
# solutions for the problem at hand. Since each individual is represented by some chromosome, this 
# population of individuals can be seen as a collection of such chromosomes:
# The population continually represents the current generation and evolves when the current generation 
# is replaced by a new one.

#  Fitness function
#  At each iteration of the algorithm, the individuals are evaluated using a fitness function (also called the 
# target function). This is the function we seek to optimize or the problem we are attempting to solve.
#  Individuals who achieve a better fitness score represent better solutions and are more likely to 
# be chosen to reproduce and be represented in the next generation. Over time, the quality of the 
# solutions improves, the fitness values increase, and the process can stop once a solution is found with 
# a satisfactory fitness value

# Selection
#  After calculating the fitness of every individual in the population, a selection process is used to 
# determine which of the individuals in the population will get to reproduce and create the offspring 
# that will form the next generation.
#  T
#  his selection process is based on the fitness score of the individuals. Those with higher score values 
# are more likely to be chosen and pass their genetic material to the next generation.
#  Individuals with low fitness values can still be chosen but with a lower probability. This way, their 
# genetic material is not completely excluded, maintaining genetic diversity.

#  Crossover
#  To create a pair of new individuals, two parents are usually chosen from the current generation, 
# and parts of their chromosomes are interchanged (crossed over) to create two new chromosomes 
# representing the offspring. This operation is called crossover or recombination:

#  Mutation
#  The purpose of the mutation operator is to refresh the population, introduce new patterns into the 
# chromosomes, and encourage search in uncharted areas of the solution space periodically and randomly.
#  A mutation may manifest itself as a random change in a gene. Mutations are implemented as random 
# changes to one or more of the chromosome values; for example, flipping a bit in a binary string: (10101010 --- 10111010)

# За пример - имаме задача да намерим какъв стринг от 4 символа може да даде най-голям резултат. 0111 и 1110. При
# Комбинирането мутацията и кросовъра може да се получи 1111. Ще вземе от 1-вия към първия стинг ще вземе първата
# позиция от 2-рия стринг, ще я сложи на индекс 0 - Това е най-добрия резултат. Това евентуално ще стане с 
# итерацията на алгоритъма.

# Разлики от традиционните алгоритми

# Има няколко важни разлики между генетичните алгоритми и традиционните алгоритми за търсене и оптимизация, като тези, базирани на градиенти.

# Основните разграничителни фактори са следните:

# Поддържане на популация от решения
# Използване на генетично представяне на решенията
# Използване на резултат от функция за годност (fitness function)
# Проявяване на вероятностно поведение

# Следва подробно разглеждане: 

# Основан на популация

# Генетичното търсене се извършва върху популация от кандидат-решения (индивиди), а не върху едно единствено решение.
# Във всеки момент от търсенето алгоритъмът запазва набор от индивиди, които формират текущото поколение.
# Всяка итерация на генетичния алгоритъм създава следващото поколение индивиди.

# За разлика от това, повечето други алгоритми за търсене поддържат едно-единствено решение и го модифицират итеративно в 
# търсене на най-доброто решение. Например, алгоритъмът за спускане по градиента (gradient descent) итеративно придвижва 
# текущото решение в посока на най-стръмното спускане, което е дефинирано от отрицателния градиент на дадената функция.

# Генетично представяне

# Вместо да работят директно с кандидат-решенията, генетичните алгоритми оперират с техните представяния (или кодиране), 
# често наричани хромозоми. Пример за проста хромозома е бинарен низ с фиксирана дължина.

# Тези хромозоми улесняват извършването на генетични операции като кръстосване (crossover) и мутация (mutation).

# Кръстосването се осъществява чрез разменяне на части от хромозомите между двама родители.
# Мутацията се извършва чрез модифициране на части от хромозомата.
# Страничен ефект от използването на генетично представяне е отделянето на търсенето от първоначалната предметна област
# на проблема. Генетичните алгоритми не знаят какво представляват хромозомите и не се опитват да ги интерпретират.

# Функция за годност

# Функцията за годност представлява проблема, който искаме да решим. Целта на генетичните алгоритми е да намерят индивидите,
# които дават най-висок резултат при изчисляване на тази функция.

# За разлика от много традиционни алгоритми за търсене, генетичните алгоритми разглеждат само стойността, получена 
# от функцията за годност, без да разчитат на производни или друга допълнителна информация. Това ги прави подходящи 
# за функции, които са трудни или невъзможни за математическо диференциране.

# Вероятностно поведение

# Докато много традиционни алгоритми са детерминирани, правилата, които генетичните алгоритми използват за преминаване от едно 
# поколение към следващото, са вероятностни.

# Например, когато се избират индивидите, които ще бъдат използвани за създаване на следващото поколение, вероятността за 
# избиране на даден индивид се увеличава с неговата годност (fitness), но все пак има елемент на случайност при избора. 
# Индивиди с ниски стойности на годност също могат да бъдат избрани, макар и с по-ниска вероятност.

# Мутацията също е водена от вероятност. Обикновено тя се случва с ниска вероятност и прави промени в една или повече случайни 
# позиции в хромозомата.

# Операторът за кръстосване (crossover) също може да има вероятностен елемент. В някои варианти на генетичните алгоритми,
# кръстосването се извършва само при определена вероятност. Ако не се случи кръстосване, и двамата родители се копират в 
# следващото поколение без промяна.

# Въпреки вероятностния характер на този процес, търсенето, базирано на генетични алгоритми, не е случайно; то използва 
# случайните елементи, за да насочи търсенето към области в пространството на решенията, където има по-добър шанс за
# подобрение на резултатите.

# Предимства на генетичните алгоритми

# Уникалните характеристики на генетичните алгоритми, които обсъдихме в предходните секции, предоставят няколко предимства
# пред традиционните алгоритми за търсене.

# Основните предимства на генетичните алгоритми са следните:

# Способност за глобална оптимизация – Генетичните алгоритми не са склонни да се "заключат" в локални оптимуми и имат по-голям 
# потенциал да намерят глобалното оптимално решение.
# Могат да обработват проблеми със сложна математическа представителност – Подходящи са за задачи, при които математическата
# формула е сложна или нелинейна.
# Могат да обработват проблеми без математическа представителност – Не изискват точно математическо дефиниране на задачата.
# Устойчивост на шум – Работят добре дори когато данните или оценката на годността съдържат шум или са неточни.
# Поддръжка за паралелност и разпределена обработка – Генетичните алгоритми са естествено подходящи за паралелна обработка, 
# което ги прави ефективни при работа с големи популации.
# Подходящи за непрекъснато обучение – Могат да се използват за адаптация и оптимизация в среди, които се променят с времето.


# Предимство пред традиционните алгоритми

# Повечето традиционни алгоритми за търсене и оптимизация, особено тези, базирани на градиенти, често се "заключват" в 
# локален максимум, вместо да намерят глобалния. Това се дължи на факта, че в близост до локален максимум всяка малка 
# промяна влошава стойността на оценката.

# От друга страна, генетичните алгоритми са по-малко чувствителни към този феномен и е по-вероятно да намерят глобалния максимум. 
# Това се дължи на използването на популация от кандидат-решения вместо само едно, както и на операциите кръстосване (crossover)
# и мутация (mutation), които често генерират кандидат-решения, значително отдалечени от предишните.

# Това обаче е вярно само ако успеем да запазим разнообразието в популацията и да избегнем преждевременната конвергенция, 
# което ще бъде споменато в следващата секция.

# Работа със сложни проблеми

# Тъй като генетичните алгоритми изискват единствено резултата от функцията за годност (fitness function) за всеки индивид и
# не се интересуват от други аспекти на функцията, като производни, те могат да се използват за проблеми със сложни 
# математически представяния или за функции, които са трудни или невъзможни за диференциране.

# Други сложни случаи, в които генетичните алгоритми се справят отлично, включват:

# Проблеми с голям брой параметри.
# Проблеми с комбинация от различни типове параметри – например смесица от непрекъснати и дискретни параметри.


# Работа при липса на математическа представителност

# Генетичните алгоритми могат да се използват за проблеми, които изцяло липсват математическа представителност.
# Един такъв случай е, когато резултатът от функцията за годност (fitness score) се базира на човешко мнение.

# Например, представете си, че искаме да намерим най-привлекателната цветова палитра за уебсайт. Можем да изпробваме 
# различни цветови комбинации и да помолим потребителите да оценят тяхната привлекателност. Можем да приложим генетични 
# алгоритми, за да търсим комбинацията с най-висок резултат, използвайки тези оценки като изход от функцията за годност. 
# Генетичният алгоритъм ще работи по обичайния начин, дори когато функцията за годност няма математическа формула и няма 
# директен начин за изчисляване на резултата от дадена цветова комбинация.

# Както ще видим в следващата глава, генетичните алгоритми могат да се справят дори в случаи, когато резултатът на всеки
# индивид не може да бъде директно изчислен, стига да имаме начин да сравним два индивида и да определим кой е по-добър.

# Пример за това е машинно самообучаващ се алгоритъм, който управлява автомобил в симулирано състезание. Търсенето, базирано
# на генетичен алгоритъм, може да оптимизира и настройва машинно самообучаващия се алгоритъм, като различни негови версии се 
# съревновават една с друга, за да се определи коя версия е по-добра.

# Устойчивост на шум

# Някои проблеми показват шумово поведение. Това означава, че дори при сходни входни стойности на параметрите, изходната
# стойност може да бъде малко по-различна всеки път, когато се измерва. Това може да се случи, например, когато данните 
# се четат от сензори или в случаи, когато резултатът се базира на човешко мнение, както беше обсъдено в предходния раздел.

# Докато този вид поведение може да обърка много традиционни алгоритми за търсене, генетичните алгоритми обикновено са
# устойчиви на него, благодарение на повтарящия се процес на пресъздаване и преоценяване на индивидите.

# Паралелност

# Генетичните алгоритми са подходящи за паралелизация и разпределена обработка. Оценката на годността (fitness) се извършва
# независимо за всеки индивид, което означава, че всички индивиди в популацията могат да бъдат оценявани едновременно.

# Освен това операциите по селекция, кръстосване (crossover) и мутация (mutation) могат също да се изпълняват паралелно 
# върху индивиди или двойки индивиди в популацията.

# Това прави генетичните алгоритми естествен избор за разпределени и базирани на облак реализации.

# Непрекъснато обучение

# В природата еволюцията никога не спира. С промяната на условията на околната среда популацията се адаптира към тях.
# По същия начин генетичните алгоритми могат да работят непрекъснато в постоянно променяща се среда, като във всеки момент
# може да бъде извлечено и използвано най-доброто текущо решение.

# За да бъде това ефективно, промените в средата трябва да бъдат бавни в сравнение с времето за преминаване на едно поколение
# в търсенето, базирано на генетичен алгоритъм.



# Ограничения на генетичните алгоритми

# За да извлечем максимална полза от генетичните алгоритми, трябва да сме наясно с техните ограничения и потенциални недостатъци.

# Основните ограничения на генетичните алгоритми са следните:

# Необходимост от специални дефиниции – Изискват се подходящи дефиниции на функцията за годност, генетичното представяне и операторите.
# Необходимост от настройка на хиперпараметри – Параметри като размер на популацията, вероятност за мутация и кръстосване трябва да
# бъдат внимателно настроени за оптимална производителност.
# Интензивни изчисления – Операциите са изчислително натоварващи, особено при големи популации или сложни функции за годност.
# Риск от преждевременна конвергенция – Популацията може да се фиксира върху субоптимални решения, ако разнообразието не се поддържа.
# Няма гарантирана решение – Генетичните алгоритми не гарантират, че ще намерят най-доброто възможно решение, особено за сложни проблеми.


# Специални дефиниции

# При прилагането на генетични алгоритми към даден проблем е необходимо да създадем подходящо представяне за тях. Това включва:

# Определяне на функцията за годност (fitness function).
# Структуриране на хромозомата.
# Дефиниране на операторите за селекция, кръстосване (crossover) и мутация (mutation), които ще работят за конкретния проблем.
# Този процес често може да се окаже предизвикателен и да изисква значително време и усилия.

# Настройка на хиперпараметри

# Поведението на генетичните алгоритми се контролира от набор хиперпараметри, като например:

# Размер на популацията (population size).
# Честота на мутация (mutation rate).
# При прилагане на генетични алгоритми към даден проблем няма точни правила за избор на тези стойности.

# Това обаче е характерно за почти всички алгоритми за търсене и оптимизация. След като разгледате примерите в тази книга и
# направите свои собствени експерименти, ще можете да правите обосновани избори за тези параметри.

# Интензивни изчисления

# Работата с (потенциално големи) популации и повтарящият се характер на генетичните алгоритми могат да бъдат изчислително
# натоварващи и да отнемат значително време, преди да се достигне до добро решение.

# Тези проблеми могат да бъдат смекчени чрез:

# Подбор на подходящи хиперпараметри.
# Прилагане на паралелна обработка.
# Кеширане на междинни резултати в определени случаи.

# Преждевременна конвергенция

# Ако годността на един индивид е значително по-висока от тази на останалите в популацията, той може да бъде дублиран толкова много
# пъти, че да завладее цялата популация. Това може да доведе до "заключване" на генетичния алгоритъм в локален максимум, вместо да
# се намери глобалният.

# За да се предотврати това, е важно да се поддържа разнообразието в популацията. Различни методи за поддържане на разнообразието
# ще бъдат разгледани в следващата глава.

# Липса на гарантирано решение

# Използването на генетични алгоритми не гарантира, че глобалният максимум за дадения проблем ще бъде намерен.

# Това обаче е валидно за почти всички алгоритми за търсене и оптимизация, освен ако не става въпрос за аналитично решение 
# на специфичен тип проблем.

# Обикновено генетичните алгоритми, когато се използват правилно, са известни с това, че предоставят добри решения в 
# разумни времеви рамки.

# Приложения на генетичните алгоритми

# На база на материалите, разгледани в предишните секции, генетичните алгоритми са най-подходящи за следните видове проблеми:

# Проблеми със сложна математическа представителност:
# Генетичните алгоритми изискват само резултата от функцията за годност, което ги прави подходящи за проблеми с целеви функции, 
# които са трудни или невъзможни за диференциране (например планиране и разпределение).
# Проблеми с голям брой параметри (например реконструкция на изображения).
# Проблеми със смесица от типове параметри (например оптимизация на хиперпараметри).

# Проблеми без математическа представителност:

# Генетичните алгоритми не изискват математическо описание на проблема, стига да може да се изчисли стойност на резултата или да 
# има метод за сравнение на две решения.
# Това е полезно при задачи като:
# Укрепващо обучение (reinforcement learning).
# Оптимизация на архитектурата на дълбоки обучителни модели (deep learning).
# Проблеми в шумна среда:

# Генетичните алгоритми са устойчиви на условия, където данните може да са непостоянни, например:
# Данни от сензори.
# Оценяване, базирано на човешко мнение (например избор на най-добра цветова палитра за уебсайт според обратна връзка от клиенти и 
#                                        техните модели на използване).
# Проблеми в среда, която се променя с времето:

# Генетичните алгоритми могат да реагират на бавни промени в средата чрез непрекъснато създаване на нови поколения, които да се
# адаптират към тези промени.
# Пример: Цветовата палитра на уебсайт може да се адаптира към променящите се предпочитания на клиентите в съответствие с модните
# тенденции.
# Въпреки това, когато проблемът има известен и специализиран метод за решаване, използването на съществуващ традиционен или
# аналитичен метод е вероятно по-ефективен избор.

# Резюме

# В тази глава започнахме с въведение в генетичните алгоритми, тяхната аналогия с Дарвиновата еволюция и основните принципи на работа,
# включително използването на популация, генотип, функция за годност и генетичните оператори: селекция, кръстосване и мутация.

# След това разгледахме теорията, стояща в основата на генетичните алгоритми, като обсъдихме хипотезата за изграждащите блокове 
# (building-block hypothesis) и теоремата за схемата (schema theorem). Илюстрирахме как генетичните алгоритми създават най-добрите
# решения, комбинирайки превъзходни, малки изграждащи блокове.

# Продължихме, като обсъдихме разликите между генетичните алгоритми и традиционните, включително поддържането на популация от решения 
# и използването на генетично представяне на тези решения.

# След това разгледахме силните страни на генетичните алгоритми, като тяхната способност за глобална оптимизация, работа със сложни 
# или несъществуващи математически представителности, както и устойчивостта им на шум. Разгледахме и слабостите им, включително 
# нуждата от специални дефиниции, настройка на хиперпараметри и риска от преждевременна конвергенция.

# Завършихме с разглеждане на случаите, в които използването на генетичен алгоритъм може да бъде полезно, като например при
# математически сложни проблеми и задачи за оптимизация в шумна или непрекъснато променяща се среда.

# В следващата глава ще се задълбочим в ключовите компоненти и детайли по имплементацията на генетичните алгоритми, като подготовка 
# за следващите глави, където ще ги използваме за кодиране на решения за различни видове проблеми.




# Създаване на начална популация

# Началната популация представлява набор от валидни кандидат-решения (индивиди), които се избират случайно.

# Тъй като генетичните алгоритми използват хромозома за представяне на всеки индивид, началната популация е набор от хромозоми. 
# Тези хромозоми трябва да съответстват на избрания формат за хромозома, подходящ за конкретния проблем – например, бинарни низове
# с определена дължина.

# Изчисляване на годността

# Стойността на функцията за годност (fitness function) се изчислява за всеки индивид. Това се прави веднъж за началната популация и 
# след това за всяко ново поколение, след прилагане на генетичните оператори: селекция, кръстосване и мутация.

# Тъй като годността на всеки индивид е независима от останалите, тези изчисления могат да се извършват паралелно.

# Тъй като етапът на селекция, който следва изчисляването на годността, обикновено разглежда индивиди с по-високи стойности на 
# годност като по-добри решения, генетичните алгоритми са естествено насочени към намиране на максимални стойности на функцията за 
# годност.

# Ако проблемът изисква минимална стойност, изчислението на годността трябва да обърне оригиналната стойност – например, чрез 
# # умножаване по -1.

# Прилагане на селекция, кръстосване и мутация

# Прилагането на генетичните оператори – селекция, кръстосване и мутация – върху популацията води до създаване на ново поколение,
# базирано на по-добри индивиди от текущите.

# Оператор за селекция

# Отговаря за избора на индивиди от текущата популация, като дава предимство на по-добрите индивиди.
# Примери за методи за селекция са разгледани в секцията Selection methods.
# Оператор за кръстосване (рекомбинация)

# Създава потомство от избраните индивиди.
# Обикновено това става чрез избиране на два индивида наведнъж и разменяне на части от техните хромозоми, за да се създадат две нови
# хромозоми, представляващи потомството.
# Примери за методи за кръстосване са разгледани в секцията Crossover methods.
# Оператор за мутация

# Случайно въвежда промяна в една или повече стойности на хромозомите (гени) на всеки новосъздаден индивид.
# Мутацията обикновено се случва с много ниска вероятност.
# Примери за методи за мутация са разгледани в секцията Mutation methods.

# Проверка на условията за спиране

# Има множество условия, които могат да се използват за определяне дали процесът трябва да бъде спрян. Най-често използваните 
# условия за спиране са следните:

# Достигнат е максимален брой поколения:

# Това условие ограничава времето за изпълнение и ресурсите, изразходвани от алгоритъма.
# Липса на забележимо подобрение в последните няколко поколения:

# Реализира се чрез съхраняване на най-добрата стойност на годност (fitness), постигната във всяко поколение, и сравняване на 
# текущата най-добра стойност с тази, постигната преди определен брой поколения. Ако разликата е по-малка от предварително зададен
# праг, алгоритъмът може да спре.
# Други възможни условия за спиране:

# Представянето на текущия най-добър индивид отговаря или надвишава изискванията на конкретния случай на използване.
# Изтекло е предварително зададено време от началото на процеса.
# Изразходван е определен ресурс, като време на процесора или памет.
# Най-доброто решение е обхванало по-голяма част от популацията от предварително зададен праг.
# Обобщение на потока на генетичния алгоритъм:

# Процесът започва с популация от случайно генерирани кандидат-решения (индивиди), които се оценяват спрямо функцията за годност.
# В сърцето на алгоритъма стои цикъл, където последователно се прилагат генетичните оператори (селекция, кръстосване и мутация),
# следвани от преоценка на индивидите.
# Цикълът продължава, докато не се изпълни условие за спиране.
# Най-добрият индивид от съществуващата популация се избира като решение.


# Методи за селекция

# Селекцията се използва в началото на всеки цикъл в потока на генетичния алгоритъм, за да се изберат индивиди от текущата популация,
# които ще бъдат използвани като родители за индивидите в следващото поколение.

# Селекцията е базирана на вероятност, като вероятността даден индивид да бъде избран е свързана с неговата стойност на годност
# (fitness), така че да се дава предимство на индивиди с по-висока годност.

# Следващите секции описват някои от най-често използваните методи за селекция и техните характеристики.


# Метод на рулетката (Roulette Wheel Selection)

# Методът на рулетката, известен още като селекция на база пропорционалност към годността (Fitness Proportionate Selection, FPS), 
# определя вероятността за избиране на индивид директно пропорционално на неговата стойност на годност (fitness).

# Това е сравнимо с използването на рулетка в казино, при което на всеки индивид се присвоява част от колелото, пропорционална на
# неговата годност. Когато колелото се завърти, шансът даден индивид да бъде избран е пропорционален на размера на частта от колелото,
# която той заема.

# Пример:
# Да предположим, че имаме популация от шест индивида със следните стойности на годност, както е показано в таблицата:

# Индивид	Годност	Относителна част от рулетката
# A	8	7%
# B	12	11%
# C	27	24%
# D	4	3%
# E	45	40%
# F	17	15%
# При всяко завъртане на рулетката точката на избиране се използва за избор на един индивид от цялата популация. След това рулетката
# се завърта отново за избор на следващия индивид, докато не бъдат избрани достатъчно индивиди за попълване на следващото поколение.

# Характеристики:

# Един и същи индивид може да бъде избран няколко пъти.
# Индивидите с по-висока годност имат по-голям шанс да бъдат избрани, но и индивиди с по-ниска годност имат известна вероятност да
# бъдат избрани, което поддържа разнообразието в популацията.



# Селекция чрез стохастично универсално пробиране (Stochastic Universal Sampling, SUS)

# Стохастичното универсално пробиране е леко модифицирана версия на метода на рулетката. Използва се същото рулетно колело с
# пропорционални дялове, но вместо да се използва една точка за избор и да се върти рулетката многократно, се завърта рулетката
# само веднъж и се използват множество точки за избор, които са равномерно разположени по колелото.

# Характеристики на SUS:

# Всички индивиди се избират едновременно чрез няколко точки за избор.
# Методът предотвратява доминирането на индивиди с изключително висока годност, които могат да заемат голяма част от следващото поколение.
# Осигурява шанс на по-слабите индивиди да бъдат избрани, намалявайки несправедливостта, която може да се прояви в оригиналния метод
# на рулетката.
# Предимства на SUS:

# По-добро разпределение на индивидите в следващото поколение.
# Запазва разнообразието в популацията.
# Подходящ за избягване на преждевременна конвергенция.
# Пример:
# Представете си, че имаме рулетно колело с пропорции, базирани на годността на индивидите, както в метода на рулетката. Вместо
# едно завъртане и една точка за избор, поставяме няколко точки за избор, равномерно разпределени по периферията на колелото. Това 
# гарантира, че повече индивиди, включително такива с по-ниска годност, имат шанс да бъдат избрани.

# Селекция на база рангове (Rank-Based Selection)

# Методът за селекция на база рангове е подобен на метода на рулетката, но вместо директно да използва стойностите на годността за 
# изчисляване на вероятностите за избор, годността се използва само за сортиране на индивидите. След сортирането всеки индивид
# получава ранг, представляващ неговата позиция, а вероятностите за избор се изчисляват на база тези рангове.

# Пример:
# Да използваме същата популация от шест индивида с годност, както в предишния пример:

# Индивид	Годност	Ранг	Относителна част от рулетката
# A	8	2	9%
# B	12	3	14%
# C	27	5	24%
# D	4	1	5%
# E	45	6	29%
# F	17	4	19%
# Характеристики:

# Предотвратяване на доминирането от няколко индивида с висока годност:
# Използването на рангове вместо директни стойности на годност премахва големите разлики във вероятностите за избор.
# Подобрена селекция при малки разлики в годността:
# Ако индивидите имат сходни стойности на годност, ранговете ще ги раздалечат, като дадат по-ясно предимство на по-добрите индивиди.
# Предимства:

# Балансирано разпределение на индивидите в следващото поколение.
# Поддържа разнообразие, когато има индивиди с изключително висока годност.
# Повишава ефективността, когато годностите са близки една до друга.
# Методът за селекция на база рангове е полезен при:

# Сценарии, в които няколко индивида имат много по-висока годност от останалите.
# Случаи, когато всички индивиди имат сходни стойности на годност и се търси по-добро разпределение.

# Скалиране на годността (Fitness Scaling)

# Докато селекцията на база рангове заменя стойностите на годността с рангове, скалирането на годността прилага трансформационна 
# скала към суровите стойности на годността и ги заменя с резултата от трансформацията. Тази трансформация преобразува суровите 
# стойности на годността в желания диапазон, използвайки формулата:

# scaled fitness = 𝑎 ×(raw fitness) + 𝑏

# Където:
# a и 𝑏 са константи, които избираме, за да постигнем желания диапазон на скалираните стойности на годност.
# Пример:
# Да използваме предишния набор от индивиди с диапазон на суровите стойности на годност между 4 (индивид D) и 45 (индивид E). 
# Ако искаме да преобразуваме стойностите в нов диапазон между 50 и 100:

# Уравнения за определяне на  a и 𝑏

# 50 = a * 4 + b
# 100 = a * 45 + b

# Решение на системата уравнения:

# a = 1.22
# b = 45.12

# Формулата за скалирана годност става:

# scaled_fitness = 1.22 * (raw_fitness) + 45.12

# The scaled fitness values and relative shares are:

# Индивид	Годност	Скалирана годност	Относителна част от рулетката
# A	8	55	13%
# B	12	60	15%
# C	27	78	19%
# D	4	50	12%
# E	45	100	25%
# F	17	66	16%

# Характеристики на скалирането на годността:
# Контрол на диапазона: Осигурява стойности в желания диапазон, което прави селекцията по-балансирана.
# Избягване на доминиране: Намалява ефекта на много високи стойности на годност върху селекцията.
# Подобрена чувствителност: При близки стойности на годност разликите стават по-ясно изразени.
# Кога е полезно?
# Когато диапазонът на суровите стойности е твърде широк или твърде тесен.
# За поддържане на разнообразие и баланс в селекцията, като същевременно се осигурява справедливост.

# Както е илюстрирано на Фигура 2.5, скалирането на стойностите на годността в новия диапазон осигурява много по-умерено разпределение
# на рулетката в сравнение с оригиналното разпределение.

# Най-добрият индивид (със скалирана стойност на годността от 100) сега има само два пъти по-голям шанс да бъде избран в сравнение
# с най-лошия (със скалирана стойност на годността от 50). За сравнение, при използване на суровите стойности на годността, шансът 
# на най-добрия индивид да бъде избран беше повече от 11 пъти по-голям.

# Заключение:
# Скалирането на годността помага за постигане на по-балансирано и справедливо разпределение, което ограничава доминирането на 
# най-добрите индивиди и поддържа разнообразието в популацията.

# Турнирна селекция

# При всяко кръгче на метода за турнирна селекция два или повече индивида се избират на случаен принцип от популацията, и този
# с най-висока стойност на годност (fitness score) печели и бива избран.

# Пример:
# Да предположим, че имаме същите шест индивида и същите стойности на годност, използвани в предишните примери. Следващата 
# илюстрация показва случайния избор на трима от тях (A, B и F). След това индивид F е обявен за победител, тъй като има
# най-високата стойност на годност (17) сред тези трима индивида.

# Броят на индивидите, участващи във всяко кръгче на турнирната селекция (в нашия пример – трима), се нарича размер на турнира
# (tournament size).

# Ефект от размера на турнира:
# Колкото по-голям е размерът на турнира, толкова по-големи са шансовете най-добрите индивиди да участват в турнирите и да бъдат избрани.
# Това намалява вероятността индивиди с ниски стойности на годност да спечелят турнир и да бъдат избрани.
# По-малкият размер на турнира увеличава шансовете по-слаби индивиди да участват, което подпомага запазването на разнообразието
# в популацията.
# Интересен аспект:

# При този метод е достатъчно да можем да сравним двама индивиди и да определим кой от тях е по-добър.
# Не е необходимо да разполагаме с точните стойности на функцията за годност (fitness function).


# Методи за кръстосване

# Операторът за кръстосване, наричан също рекомбинация, съответства на процеса на кръстосване, който се случва по време на сексуалната 
# репродукция в биологията. Той се използва за комбиниране на генетичната информация на двама индивиди, които служат като родители,
# за да се произведат (обикновено две) потомства.

# Приложение на кръстосване:
# Операторът за кръстосване обикновено се прилага с определена (висока) вероятност.
# В случаите, когато кръстосването не се прилага, и двамата родители се клонират директно в следващото поколение.
# Допълнителни бележки:
# Следващите раздели описват някои от най-често използваните методи за кръстосване и техните типични приложения. Въпреки това,
# в определени ситуации може да изберете специфичен за проблема метод на кръстосване, който е по-подходящ за конкретния случай.

# Кръстосване с една точка (Single-Point Crossover)

# При метода на кръстосване с една точка се избира случайно място върху хромозомите на двамата родители. Това място се нарича точка
# на кръстосване (crossover point) или точка на рязане (cut point).

# Как работи:
# Гените вдясно от точката на кръстосване се разменят между двете хромозоми на родителите.
# В резултат се получават две потомства, всяко от които съдържа част от генетичната информация и на двамата родители.
# Пример:
# Представете си, че имаме двойка бинарни хромозоми, и точката на кръстосване е избрана между петия и шестия ген. Процесът на
# кръстосване изглежда по следния начин:

# Родител 1: 10101 | 0101
# Родител 2: 11010 | 1010
# След кръстосването получаваме:

# Потомство 1: 10101 | 1010
# Потомство 2: 11010 | 0101
# Характеристики:

# Този метод е прост за изпълнение и осигурява разумна комбинация на генетична информация между родителите.
# Подходящ е за широк спектър от приложения, когато хромозомите са линейно подредени.

# Кръстосване с две точки и k-точково кръстосване

# При метода на кръстосване с две точки се избират две точки на кръстосване върху хромозомите на двамата родители на случаен принцип. 
# Гените, които се намират между тези точки, се разменят между хромозомите на родителите.

# Пример:
# Представете си двойка бинарни хромозоми, като първата точка на кръстосване е разположена между третия и четвъртия ген, а втората –
# между седмия и осмия ген. Процесът изглежда така:

# Родител 1: 101 | 01011 | 001
# Родител 2: 110 | 11000 | 010
# След кръстосването получаваме:

# Потомство 1: 101 | 11000 | 001
# Потомство 2: 110 | 01011 | 010
# Забележки:

# Методът на кръстосване с две точки може да се реализира чрез прилагане на два единични кръстосвания, всяко с различна точка на рязане.
# Тази техника позволява по-силно комбиниране на генетична информация в сравнение с едноточковото кръстосване.
# Обобщение за k-точково кръстосване:

# Методът е обобщение на кръстосването с две точки, при което k представлява положително цяло число, а k точки на кръстосване се използват.
# При всяко от тези точки частите на хромозомите между съседните точки се разменят между родителите.
# Този метод осигурява още по-голямо разнообразие в комбинацията на гените, което може да бъде полезно за сложни задачи или когато
# е необходимо интензивно смесване на генетична информация.

# Униформено кръстосване (Uniform Crossover)

# При метода на униформено кръстосване всяко ген от потомството се определя независимо чрез случаен избор на един от двамата родители.

# Случайно разпределение:
# Ако разпределението е 50%, всеки родител има еднакъв шанс да повлияе върху потомството.
# Пример:
# Представете си хромозоми, представени чрез цели числа. Гените за всяко потомство се избират на случаен
# принцип от гените на двамата  родители.

# Бележка:

# В този пример второто потомство е създадено чрез допълване на избора, направен за първото потомство.
# Въпреки това, двете потомства могат да бъдат създадени независимо едно от друго.
# Важна бележка:

# В примера са използвани хромозоми на базата на цели числа, но методът работи по същия начин и за бинарни хромозоми.
# Тъй като този метод не разменя цели сегменти от хромозомата, той предлага по-голям потенциал за разнообразие в генетичната 
# информация на потомството.
# Този метод е полезен за задачи, при които е важно да се осигури висока степен на разнообразие, като по този начин се избягва 
# преждевременната конвергенция на популацията.

# Кръстосване за подредени списъци

# В предишния пример разгледахме резултатите от операция на кръстосване върху две хромозоми, базирани на цели числа.
#  Докато всяка от хромозомите на родителите съдържаше всяка стойност между 0 и 9 точно веднъж, потомците имаха дублирани
#   стойности (например 2 в първото потомство и 1 във второто) и липсващи стойности (например 4 в първото потомство и 5 във второто).

# В някои задачи обаче хромозомите, базирани на цели числа, може да представляват индекси на подреден списък.

# Пример:
# Представете си, че имаме няколко града, за които знаем разстоянието между всеки от тях, и трябва да намерим най-краткия 
# възможен маршрут, който минава през всички тях. Това е известно като задачата на пътуващия търговец (Traveling Salesman Problem),
#  която ще бъде разгледана подробно в една от следващите глави.

# Ако имаме четири града, удобен начин за представяне на възможно решение на този проблем е чрез хромозома от четири цели числа,
#  показващи реда за посещение на градовете – например (1, 2, 3, 4) или (3, 4, 2, 1).

# Хромозома с дублирани стойности или липсваща стойност, като например (1, 2, 2, 4), няма да представлява валидно решение.

# Алтернативни методи за кръстосване:
# За такива случаи са разработени алтернативни методи за кръстосване, които гарантират, че създадените потомци ще останат валидни.
#  Един от тези методи е подреденото кръстосване (Ordered Crossover, OX1), който ще бъде разгледан в следващия раздел.

# OX1 (Подредено кръстосване)

# Методът OX1 се стреми да запази относителния ред на гените на родителите, доколкото е възможно. Ще го демонстрираме,
#  използвайки хромозоми с дължина 6.

# Пример:

# В примера използваме хромозоми, базирани на цели числа, но методът работи по същия начин с бинарни хромозоми.
# Стъпка 1: Извършва се кръстосване с две точки, като точките на рязане се избират на случаен принцип.
# Първи етап:

# От хромозомите на родителите се изрязва сегмент между двете точки. Този сегмент се копира директно в съответните потомци.
# Резултатите след първия етап съдържат сегмент от всеки родител, но останалите позиции остават празни.
# Втори етап:

# За всяко потомство се попълват останалите гени, като се преминава през гените на съответния родител в оригиналния им ред,
#  започвайки след втората точка на рязане.
# Ако генът вече присъства в потомството, се преминава към следващия ген, докато се намери ген, който липсва.
# Демонстрация:

# За първото потомство:
# Първият липсващ ген след втората точка е 2. Той се добавя към потомството.
# Следва 4, който също се добавя.
# За второто потомство:
# Първият липсващ ген след втората точка е 6. Той се добавя.
# Следва 3, който също се добавя.
# Последен етап:

# Процесът продължава, докато всички празни места в потомствата бъдат запълнени.
# Резултатът са две валидни хромозоми за потомците, които запазват реда на гените от родителите и нямат дублиращи се 
# или липсващи стойности.
# Предимства на OX1:

# Осигурява валидни решения за задачи, където редът на елементите е от значение (като задачата на пътуващия търговец).
# Съхранява колкото се може повече информация от родителите.
# Заключение:
# Съществуват и други методи за кръстосване, някои от които ще бъдат разгледани по-нататък в книгата. Благодарение на
#  гъвкавостта на генетичните алгоритми, винаги можете да разработите собствен метод, адаптиран към конкретния проблем.

# Методи за мутация

# Мутацията е последният генетичен оператор, който се прилага в процеса на създаване на ново поколение.

# Приложение на оператора за мутация:

# Той се прилага върху потомците, създадени в резултат на селекция и кръстосване.
# Операторът за мутация е базиран на вероятност и обикновено се случва с (много) ниска вероятност, тъй като носи риск от влошаване
#  на представянето на индивида, върху който се прилага.
# Адаптиране на вероятността за мутация:

# В някои версии на генетичните алгоритми вероятността за мутация постепенно се увеличава с напредването на поколенията.
# Цел: Да се предотврати застой и да се гарантира разнообразие в популацията.
# Обаче, ако честотата на мутацията е прекалено висока, генетичният алгоритъм ще се превърне в еквивалент на случаен търсене.
# Следващи секции:
# Ще бъдат разгледани някои от най-често използваните методи за мутация и техните типични приложения. Винаги можете да изберете 
# да използвате собствен метод за мутация, съобразен с конкретния проблем, който решавате.



# Мутация чрез обръщане на бит (Flip-Bit Mutation)

# При прилагане на метода за мутация чрез обръщане на бит върху бинарна хромозома, един ген се избира на случаен принцип
#  и неговата стойност се обръща (допълва).

# Пример:

# Хромозома преди мутация: 101011
# Случайно избраният ген е третият бит (отляво).
# Хромозома след мутация: 100011
# Разширение:

# Този метод може да бъде разширен така, че вместо само един ген, няколко случайно избрани гена да бъдат обърнати.
# Характеристики:

# Подходящ за бинарни хромозоми, като лесно и ефективно внася разнообразие в популацията.
# Обикновено се използва с ниска вероятност, за да се избегне влошаване на качеството на решенията.
# Този метод е прост за изпълнение и често се използва в генетични алгоритми, които работят с бинарни представяния.

# Размяна на гени (Swap Mutation)

# При прилагане на мутация чрез размяна върху бинарни или хромозоми, базирани на цели числа, два гена се избират на случаен
#  принцип и техните стойности се разменят.

# Пример:

# Хромозома преди мутация: (1, 2, 3, 4, 5)
# Избрани гени: Вторият и четвъртият.
# Хромозома след мутация: (1, 4, 3, 2, 5)
# Характеристики:

# Тази операция е подходяща за хромозоми, представляващи подредени списъци, тъй като новата хромозома запазва същите гени 
# като оригиналната.

# Мутация чрез инверсия (Inversion Mutation)

# При прилагане на мутация чрез инверсия върху бинарни или хромозоми, базирани на цели числа, се избира случайна последователност 
# от гени, след което редът на гените в тази последователност се обръща.

# Пример:

# Хромозома преди мутация: (1, 2, 3, 4, 5, 6)
# Избрана последователност: От третия до петия ген.
# Хромозома след мутация: (1, 2, 6, 5, 4, 3)
# Характеристики:

# Подобно на мутацията чрез размяна, операцията чрез инверсия е подходяща за хромозоми, представляващи подредени списъци.
# Новата хромозома запазва същите гени като оригиналната, като просто променя техния ред.

# Мутация чрез разбъркване (Scramble Mutation)

# Друг оператор за мутация, подходящ за хромозоми на подредени списъци, е мутацията чрез разбъркване. При прилагане на този
#  метод се избира случайна последователност от гени, и редът на гените в тази последователност се разбърква (shuffle).

# Пример:

# Хромозома преди мутация: (1, 2, 3, 4, 5, 6)
# Избрана последователност: От третия до петия ген.
# Хромозома след мутация: (1, 2, 5, 3, 4, 6) (редът на гените в избраната последователност е променен).
# Характеристики:

# Подобно на мутацията чрез инверсия, мутацията чрез разбъркване запазва същите гени като оригиналната хромозома.
# Основната разлика е, че вместо да обръща реда на гените, тя ги подрежда в случаен ред.

Генетични алгоритми с реално кодиране

# Досега разгледахме хромозоми, които представляват бинарни или цели числови параметри. Следователно генетичните оператори,
#  които обсъждахме, бяха подходящи за работа с тези типове хромозоми. Често обаче срещаме проблеми, при които пространството
#   на решенията е непрекъснато, т.е. индивидите са съставени от реални числа (floating-point numbers).

# Исторически подход:
# Първоначално генетичните алгоритми са използвали бинарни низове за представяне на цели числа и реални числа.
# Ограничения на този подход:
# Точност: Прецизността на реално число, представено чрез бинарен низ, зависи от дължината на низа (броя на битовете).
# Кратки низове → недостатъчна прецизност.
# Дълги низове → излишна сложност.
# Значимост на битовете: Местоположението на всеки бит в низа определя неговата значимост. Например:
# Схема 1**** (всички петбитови низове, започващи с 1) носи много повече значение от схемата ****1 (низове, завършващи с 1),
#  въпреки че и двете имат ред 1 и дефинираща дължина 0.
# Подход с реално кодиране:
# Вместо бинарни низове се използват масиви от реални числа, които са по-прости и ефективни.
# Пример за хромозома с три реални параметъра:
# [x1, x2, x3], където x1, x2 и x3 са реални числа, като [1.23, 7.2134, -25.309] или [-30.10, 100.2, 42.424].
# Селекция:
# Методите за селекция, описани по-рано, работят същото за реално кодирани хромозоми, тъй като зависят от годността на индивидите,
#  а не от тяхното представяне.
# Кръстосване и мутация:
# Ограничения: Методите за кръстосване и мутация, които разгледахме досега, не са подходящи за реално кодирани хромозоми.
# Специализирани методи: Необходими са специални оператори за кръстосване и мутация, приложими за реални числа.
# Операциите се извършват поотделно за всяко измерение в масива.
# Пример за кръстосване на реално кодирани хромозоми:
# Ако [1.23, 7.213, -25.39] и [-30.10, 100.2, 42.42] са родители, кръстосването се извършва поотделно за:

# 1.23 и -30.10 (първо измерение).
# 7.213 и 100.2 (второ измерение).
# -25.39 и 42.42 (трето измерение).
# Пример за мутация:
# Мутацията също се прилага поотделно за всяко измерение в хромозомата.