# Hands-On  Genetic Algorithms with Python by  Eyal Wirsansky

# What are genetic algorithms?
# Genetic algorithms are a family of search algorithms that are inspired by the principles of evolution in 
# nature. By imitating the process of natural selection and reproduction, genetic algorithms can produce 
# high-quality solutions for various problems involving search, optimization, and learning. At the same 
# time, their analogy to natural evolution allows genetic algorithms to overcome some of the hurdles 
# that are encountered by traditional search and optimization algorithms, especially for problems with 
# a large number of parameters and complex mathematical representations.

# The principle of variation: The traits (attributes) of individual specimens belonging to a 
# population may vary. As a result, the specimens differ from each other to some degree, for 
# example, in their behavior or appearance.
#  • The principle of inheritance: Some traits are consistently passed on from specimens to their 
# offspring. As a result, offspring resemble their parents more than they resemble unrelated specimens.
#  • The principle of selection: Populations typically struggle for resources within their given 
# environment. The specimens possessing traits that are better adapted to the environment will 
# be more successful at surviving and will also contribute more offspring to the next generation.

# Генетичните алгоритми поддържат набор от решения за даден пробле, наречен individuals. Тези кандидати се оценявят 
# итеративно и най-добрите от тях се избират за създаване на следващо решение.

# Genotype - Генотип
#  В природата размножаването, размножаването и мутацията се улесняват чрез генотипа – колекция от гени 
# които са групирани в хромозоми. Ако два екземпляра се размножават, за да създадат потомство, всяка хромозома от 
# потомството ще носи комбинация от гени и от двамата родители. Имитиране на тази концепция, в случай на генетични 
# алгоритми, всеки индивид е представен от хромозома, представляваща колекция от гени. За 
# Например, една хромозома може да бъде изразена като двоичен низ, където всеки бит представлява един ген

# Genotype
#  In nature, breeding, reproduction, and mutation are facilitated via the genotype – a collection of genes 
# that are grouped into chromosomes. If two specimens breed to create offspring, each chromosome of 
# the offspring will carry a mix of genes from both parents. Mimicking this concept, in the case of genetic 
# algorithms, each individual is represented by a chromosome representing a collection of genes. For 
# example, a chromosome can be expressed as a binary string, where each bit represents a single gene:

# Population
#  At any point in time, genetic algorithms maintain a population of individuals – a collection of candidate 
# solutions for the problem at hand. Since each individual is represented by some chromosome, this 
# population of individuals can be seen as a collection of such chromosomes:
# The population continually represents the current generation and evolves when the current generation 
# is replaced by a new one.

#  Fitness function
#  At each iteration of the algorithm, the individuals are evaluated using a fitness function (also called the 
# target function). This is the function we seek to optimize or the problem we are attempting to solve.
#  Individuals who achieve a better fitness score represent better solutions and are more likely to 
# be chosen to reproduce and be represented in the next generation. Over time, the quality of the 
# solutions improves, the fitness values increase, and the process can stop once a solution is found with 
# a satisfactory fitness value

# Selection
#  After calculating the fitness of every individual in the population, a selection process is used to 
# determine which of the individuals in the population will get to reproduce and create the offspring 
# that will form the next generation.
#  T
#  his selection process is based on the fitness score of the individuals. Those with higher score values 
# are more likely to be chosen and pass their genetic material to the next generation.
#  Individuals with low fitness values can still be chosen but with a lower probability. This way, their 
# genetic material is not completely excluded, maintaining genetic diversity.

#  Crossover
#  To create a pair of new individuals, two parents are usually chosen from the current generation, 
# and parts of their chromosomes are interchanged (crossed over) to create two new chromosomes 
# representing the offspring. This operation is called crossover or recombination:

#  Mutation
#  The purpose of the mutation operator is to refresh the population, introduce new patterns into the 
# chromosomes, and encourage search in uncharted areas of the solution space periodically and randomly.
#  A mutation may manifest itself as a random change in a gene. Mutations are implemented as random 
# changes to one or more of the chromosome values; for example, flipping a bit in a binary string: (10101010 --- 10111010)

# За пример - имаме задача да намерим какъв стринг от 4 символа може да даде най-голям резултат. 0111 и 1110. При
# Комбинирането мутацията и кросовъра може да се получи 1111. Ще вземе от 1-вия към първия стинг ще вземе първата
# позиция от 2-рия стринг, ще я сложи на индекс 0 - Това е най-добрия резултат. Това евентуално ще стане с 
# итерацията на алгоритъма.

# Разлики от традиционните алгоритми

# Има няколко важни разлики между генетичните алгоритми и традиционните алгоритми за търсене и оптимизация, като тези, базирани на градиенти.

# Основните разграничителни фактори са следните:

# Поддържане на популация от решения
# Използване на генетично представяне на решенията
# Използване на резултат от функция за годност (fitness function)
# Проявяване на вероятностно поведение

# Следва подробно разглеждане: 

# Основан на популация

# Генетичното търсене се извършва върху популация от кандидат-решения (индивиди), а не върху едно единствено решение.
# Във всеки момент от търсенето алгоритъмът запазва набор от индивиди, които формират текущото поколение.
# Всяка итерация на генетичния алгоритъм създава следващото поколение индивиди.

# За разлика от това, повечето други алгоритми за търсене поддържат едно-единствено решение и го модифицират итеративно в 
# търсене на най-доброто решение. Например, алгоритъмът за спускане по градиента (gradient descent) итеративно придвижва 
# текущото решение в посока на най-стръмното спускане, което е дефинирано от отрицателния градиент на дадената функция.

# Генетично представяне

# Вместо да работят директно с кандидат-решенията, генетичните алгоритми оперират с техните представяния (или кодиране), 
# често наричани хромозоми. Пример за проста хромозома е бинарен низ с фиксирана дължина.

# Тези хромозоми улесняват извършването на генетични операции като кръстосване (crossover) и мутация (mutation).

# Кръстосването се осъществява чрез разменяне на части от хромозомите между двама родители.
# Мутацията се извършва чрез модифициране на части от хромозомата.
# Страничен ефект от използването на генетично представяне е отделянето на търсенето от първоначалната предметна област
# на проблема. Генетичните алгоритми не знаят какво представляват хромозомите и не се опитват да ги интерпретират.

# Функция за годност

# Функцията за годност представлява проблема, който искаме да решим. Целта на генетичните алгоритми е да намерят индивидите,
# които дават най-висок резултат при изчисляване на тази функция.

# За разлика от много традиционни алгоритми за търсене, генетичните алгоритми разглеждат само стойността, получена 
# от функцията за годност, без да разчитат на производни или друга допълнителна информация. Това ги прави подходящи 
# за функции, които са трудни или невъзможни за математическо диференциране.

# Вероятностно поведение

# Докато много традиционни алгоритми са детерминирани, правилата, които генетичните алгоритми използват за преминаване от едно 
# поколение към следващото, са вероятностни.

# Например, когато се избират индивидите, които ще бъдат използвани за създаване на следващото поколение, вероятността за 
# избиране на даден индивид се увеличава с неговата годност (fitness), но все пак има елемент на случайност при избора. 
# Индивиди с ниски стойности на годност също могат да бъдат избрани, макар и с по-ниска вероятност.

# Мутацията също е водена от вероятност. Обикновено тя се случва с ниска вероятност и прави промени в една или повече случайни 
# позиции в хромозомата.

# Операторът за кръстосване (crossover) също може да има вероятностен елемент. В някои варианти на генетичните алгоритми,
# кръстосването се извършва само при определена вероятност. Ако не се случи кръстосване, и двамата родители се копират в 
# следващото поколение без промяна.

# Въпреки вероятностния характер на този процес, търсенето, базирано на генетични алгоритми, не е случайно; то използва 
# случайните елементи, за да насочи търсенето към области в пространството на решенията, където има по-добър шанс за
# подобрение на резултатите.

# Предимства на генетичните алгоритми

# Уникалните характеристики на генетичните алгоритми, които обсъдихме в предходните секции, предоставят няколко предимства
# пред традиционните алгоритми за търсене.

# Основните предимства на генетичните алгоритми са следните:

# Способност за глобална оптимизация – Генетичните алгоритми не са склонни да се "заключат" в локални оптимуми и имат по-голям 
# потенциал да намерят глобалното оптимално решение.
# Могат да обработват проблеми със сложна математическа представителност – Подходящи са за задачи, при които математическата
# формула е сложна или нелинейна.
# Могат да обработват проблеми без математическа представителност – Не изискват точно математическо дефиниране на задачата.
# Устойчивост на шум – Работят добре дори когато данните или оценката на годността съдържат шум или са неточни.
# Поддръжка за паралелност и разпределена обработка – Генетичните алгоритми са естествено подходящи за паралелна обработка, 
# което ги прави ефективни при работа с големи популации.
# Подходящи за непрекъснато обучение – Могат да се използват за адаптация и оптимизация в среди, които се променят с времето.


# Предимство пред традиционните алгоритми

# Повечето традиционни алгоритми за търсене и оптимизация, особено тези, базирани на градиенти, често се "заключват" в 
# локален максимум, вместо да намерят глобалния. Това се дължи на факта, че в близост до локален максимум всяка малка 
# промяна влошава стойността на оценката.

# От друга страна, генетичните алгоритми са по-малко чувствителни към този феномен и е по-вероятно да намерят глобалния максимум. 
# Това се дължи на използването на популация от кандидат-решения вместо само едно, както и на операциите кръстосване (crossover)
# и мутация (mutation), които често генерират кандидат-решения, значително отдалечени от предишните.

# Това обаче е вярно само ако успеем да запазим разнообразието в популацията и да избегнем преждевременната конвергенция, 
# което ще бъде споменато в следващата секция.

# Работа със сложни проблеми

# Тъй като генетичните алгоритми изискват единствено резултата от функцията за годност (fitness function) за всеки индивид и
# не се интересуват от други аспекти на функцията, като производни, те могат да се използват за проблеми със сложни 
# математически представяния или за функции, които са трудни или невъзможни за диференциране.

# Други сложни случаи, в които генетичните алгоритми се справят отлично, включват:

# Проблеми с голям брой параметри.
# Проблеми с комбинация от различни типове параметри – например смесица от непрекъснати и дискретни параметри.


# Работа при липса на математическа представителност

# Генетичните алгоритми могат да се използват за проблеми, които изцяло липсват математическа представителност.
# Един такъв случай е, когато резултатът от функцията за годност (fitness score) се базира на човешко мнение.

# Например, представете си, че искаме да намерим най-привлекателната цветова палитра за уебсайт. Можем да изпробваме 
# различни цветови комбинации и да помолим потребителите да оценят тяхната привлекателност. Можем да приложим генетични 
# алгоритми, за да търсим комбинацията с най-висок резултат, използвайки тези оценки като изход от функцията за годност. 
# Генетичният алгоритъм ще работи по обичайния начин, дори когато функцията за годност няма математическа формула и няма 
# директен начин за изчисляване на резултата от дадена цветова комбинация.

# Както ще видим в следващата глава, генетичните алгоритми могат да се справят дори в случаи, когато резултатът на всеки
# индивид не може да бъде директно изчислен, стига да имаме начин да сравним два индивида и да определим кой е по-добър.

# Пример за това е машинно самообучаващ се алгоритъм, който управлява автомобил в симулирано състезание. Търсенето, базирано
# на генетичен алгоритъм, може да оптимизира и настройва машинно самообучаващия се алгоритъм, като различни негови версии се 
# съревновават една с друга, за да се определи коя версия е по-добра.

# Устойчивост на шум

# Някои проблеми показват шумово поведение. Това означава, че дори при сходни входни стойности на параметрите, изходната
# стойност може да бъде малко по-различна всеки път, когато се измерва. Това може да се случи, например, когато данните 
# се четат от сензори или в случаи, когато резултатът се базира на човешко мнение, както беше обсъдено в предходния раздел.

# Докато този вид поведение може да обърка много традиционни алгоритми за търсене, генетичните алгоритми обикновено са
# устойчиви на него, благодарение на повтарящия се процес на пресъздаване и преоценяване на индивидите.

# Паралелност

# Генетичните алгоритми са подходящи за паралелизация и разпределена обработка. Оценката на годността (fitness) се извършва
# независимо за всеки индивид, което означава, че всички индивиди в популацията могат да бъдат оценявани едновременно.

# Освен това операциите по селекция, кръстосване (crossover) и мутация (mutation) могат също да се изпълняват паралелно 
# върху индивиди или двойки индивиди в популацията.

# Това прави генетичните алгоритми естествен избор за разпределени и базирани на облак реализации.

# Непрекъснато обучение

# В природата еволюцията никога не спира. С промяната на условията на околната среда популацията се адаптира към тях.
# По същия начин генетичните алгоритми могат да работят непрекъснато в постоянно променяща се среда, като във всеки момент
# може да бъде извлечено и използвано най-доброто текущо решение.

# За да бъде това ефективно, промените в средата трябва да бъдат бавни в сравнение с времето за преминаване на едно поколение
# в търсенето, базирано на генетичен алгоритъм.



# Ограничения на генетичните алгоритми

# За да извлечем максимална полза от генетичните алгоритми, трябва да сме наясно с техните ограничения и потенциални недостатъци.

# Основните ограничения на генетичните алгоритми са следните:

# Необходимост от специални дефиниции – Изискват се подходящи дефиниции на функцията за годност, генетичното представяне и операторите.
# Необходимост от настройка на хиперпараметри – Параметри като размер на популацията, вероятност за мутация и кръстосване трябва да
# бъдат внимателно настроени за оптимална производителност.
# Интензивни изчисления – Операциите са изчислително натоварващи, особено при големи популации или сложни функции за годност.
# Риск от преждевременна конвергенция – Популацията може да се фиксира върху субоптимални решения, ако разнообразието не се поддържа.
# Няма гарантирана решение – Генетичните алгоритми не гарантират, че ще намерят най-доброто възможно решение, особено за сложни проблеми.


# Специални дефиниции

# При прилагането на генетични алгоритми към даден проблем е необходимо да създадем подходящо представяне за тях. Това включва:

# Определяне на функцията за годност (fitness function).
# Структуриране на хромозомата.
# Дефиниране на операторите за селекция, кръстосване (crossover) и мутация (mutation), които ще работят за конкретния проблем.
# Този процес често може да се окаже предизвикателен и да изисква значително време и усилия.

# Настройка на хиперпараметри

# Поведението на генетичните алгоритми се контролира от набор хиперпараметри, като например:

# Размер на популацията (population size).
# Честота на мутация (mutation rate).
# При прилагане на генетични алгоритми към даден проблем няма точни правила за избор на тези стойности.

# Това обаче е характерно за почти всички алгоритми за търсене и оптимизация. След като разгледате примерите в тази книга и
# направите свои собствени експерименти, ще можете да правите обосновани избори за тези параметри.

# Интензивни изчисления

# Работата с (потенциално големи) популации и повтарящият се характер на генетичните алгоритми могат да бъдат изчислително
# натоварващи и да отнемат значително време, преди да се достигне до добро решение.

# Тези проблеми могат да бъдат смекчени чрез:

# Подбор на подходящи хиперпараметри.
# Прилагане на паралелна обработка.
# Кеширане на междинни резултати в определени случаи.

# Преждевременна конвергенция

# Ако годността на един индивид е значително по-висока от тази на останалите в популацията, той може да бъде дублиран толкова много
# пъти, че да завладее цялата популация. Това може да доведе до "заключване" на генетичния алгоритъм в локален максимум, вместо да
# се намери глобалният.

# За да се предотврати това, е важно да се поддържа разнообразието в популацията. Различни методи за поддържане на разнообразието
# ще бъдат разгледани в следващата глава.

# Липса на гарантирано решение

# Използването на генетични алгоритми не гарантира, че глобалният максимум за дадения проблем ще бъде намерен.

# Това обаче е валидно за почти всички алгоритми за търсене и оптимизация, освен ако не става въпрос за аналитично решение 
# на специфичен тип проблем.

# Обикновено генетичните алгоритми, когато се използват правилно, са известни с това, че предоставят добри решения в 
# разумни времеви рамки.

# Приложения на генетичните алгоритми

# На база на материалите, разгледани в предишните секции, генетичните алгоритми са най-подходящи за следните видове проблеми:

# Проблеми със сложна математическа представителност:
# Генетичните алгоритми изискват само резултата от функцията за годност, което ги прави подходящи за проблеми с целеви функции, 
# които са трудни или невъзможни за диференциране (например планиране и разпределение).
# Проблеми с голям брой параметри (например реконструкция на изображения).
# Проблеми със смесица от типове параметри (например оптимизация на хиперпараметри).

# Проблеми без математическа представителност:

# Генетичните алгоритми не изискват математическо описание на проблема, стига да може да се изчисли стойност на резултата или да 
# има метод за сравнение на две решения.
# Това е полезно при задачи като:
# Укрепващо обучение (reinforcement learning).
# Оптимизация на архитектурата на дълбоки обучителни модели (deep learning).
# Проблеми в шумна среда:

# Генетичните алгоритми са устойчиви на условия, където данните може да са непостоянни, например:
# Данни от сензори.
# Оценяване, базирано на човешко мнение (например избор на най-добра цветова палитра за уебсайт според обратна връзка от клиенти и 
#                                        техните модели на използване).
# Проблеми в среда, която се променя с времето:

# Генетичните алгоритми могат да реагират на бавни промени в средата чрез непрекъснато създаване на нови поколения, които да се
# адаптират към тези промени.
# Пример: Цветовата палитра на уебсайт може да се адаптира към променящите се предпочитания на клиентите в съответствие с модните
# тенденции.
# Въпреки това, когато проблемът има известен и специализиран метод за решаване, използването на съществуващ традиционен или
# аналитичен метод е вероятно по-ефективен избор.

# Резюме

# В тази глава започнахме с въведение в генетичните алгоритми, тяхната аналогия с Дарвиновата еволюция и основните принципи на работа,
# включително използването на популация, генотип, функция за годност и генетичните оператори: селекция, кръстосване и мутация.

# След това разгледахме теорията, стояща в основата на генетичните алгоритми, като обсъдихме хипотезата за изграждащите блокове 
# (building-block hypothesis) и теоремата за схемата (schema theorem). Илюстрирахме как генетичните алгоритми създават най-добрите
# решения, комбинирайки превъзходни, малки изграждащи блокове.

# Продължихме, като обсъдихме разликите между генетичните алгоритми и традиционните, включително поддържането на популация от решения 
# и използването на генетично представяне на тези решения.

# След това разгледахме силните страни на генетичните алгоритми, като тяхната способност за глобална оптимизация, работа със сложни 
# или несъществуващи математически представителности, както и устойчивостта им на шум. Разгледахме и слабостите им, включително 
# нуждата от специални дефиниции, настройка на хиперпараметри и риска от преждевременна конвергенция.

# Завършихме с разглеждане на случаите, в които използването на генетичен алгоритъм може да бъде полезно, като например при
# математически сложни проблеми и задачи за оптимизация в шумна или непрекъснато променяща се среда.

# В следващата глава ще се задълбочим в ключовите компоненти и детайли по имплементацията на генетичните алгоритми, като подготовка 
# за следващите глави, където ще ги използваме за кодиране на решения за различни видове проблеми.




# Създаване на начална популация

# Началната популация представлява набор от валидни кандидат-решения (индивиди), които се избират случайно.

# Тъй като генетичните алгоритми използват хромозома за представяне на всеки индивид, началната популация е набор от хромозоми. 
# Тези хромозоми трябва да съответстват на избрания формат за хромозома, подходящ за конкретния проблем – например, бинарни низове
# с определена дължина.

# Изчисляване на годността

# Стойността на функцията за годност (fitness function) се изчислява за всеки индивид. Това се прави веднъж за началната популация и 
# след това за всяко ново поколение, след прилагане на генетичните оператори: селекция, кръстосване и мутация.

# Тъй като годността на всеки индивид е независима от останалите, тези изчисления могат да се извършват паралелно.

# Тъй като етапът на селекция, който следва изчисляването на годността, обикновено разглежда индивиди с по-високи стойности на 
# годност като по-добри решения, генетичните алгоритми са естествено насочени към намиране на максимални стойности на функцията за 
# годност.

# Ако проблемът изисква минимална стойност, изчислението на годността трябва да обърне оригиналната стойност – например, чрез 
# # умножаване по -1.

# Прилагане на селекция, кръстосване и мутация

# Прилагането на генетичните оператори – селекция, кръстосване и мутация – върху популацията води до създаване на ново поколение,
# базирано на по-добри индивиди от текущите.

# Оператор за селекция

# Отговаря за избора на индивиди от текущата популация, като дава предимство на по-добрите индивиди.
# Примери за методи за селекция са разгледани в секцията Selection methods.
# Оператор за кръстосване (рекомбинация)

# Създава потомство от избраните индивиди.
# Обикновено това става чрез избиране на два индивида наведнъж и разменяне на части от техните хромозоми, за да се създадат две нови
# хромозоми, представляващи потомството.
# Примери за методи за кръстосване са разгледани в секцията Crossover methods.
# Оператор за мутация

# Случайно въвежда промяна в една или повече стойности на хромозомите (гени) на всеки новосъздаден индивид.
# Мутацията обикновено се случва с много ниска вероятност.
# Примери за методи за мутация са разгледани в секцията Mutation methods.

# Проверка на условията за спиране

# Има множество условия, които могат да се използват за определяне дали процесът трябва да бъде спрян. Най-често използваните 
# условия за спиране са следните:

# Достигнат е максимален брой поколения:

# Това условие ограничава времето за изпълнение и ресурсите, изразходвани от алгоритъма.
# Липса на забележимо подобрение в последните няколко поколения:

# Реализира се чрез съхраняване на най-добрата стойност на годност (fitness), постигната във всяко поколение, и сравняване на 
# текущата най-добра стойност с тази, постигната преди определен брой поколения. Ако разликата е по-малка от предварително зададен
# праг, алгоритъмът може да спре.
# Други възможни условия за спиране:

# Представянето на текущия най-добър индивид отговаря или надвишава изискванията на конкретния случай на използване.
# Изтекло е предварително зададено време от началото на процеса.
# Изразходван е определен ресурс, като време на процесора или памет.
# Най-доброто решение е обхванало по-голяма част от популацията от предварително зададен праг.
# Обобщение на потока на генетичния алгоритъм:

# Процесът започва с популация от случайно генерирани кандидат-решения (индивиди), които се оценяват спрямо функцията за годност.
# В сърцето на алгоритъма стои цикъл, където последователно се прилагат генетичните оператори (селекция, кръстосване и мутация),
# следвани от преоценка на индивидите.
# Цикълът продължава, докато не се изпълни условие за спиране.
# Най-добрият индивид от съществуващата популация се избира като решение.





