# This part contains the following chapters:
# • Chapter 3, Using the DEAP Framework
# • Chapter 4, Combinatorial Optimization
# • Chapter 5, Constraint Satisfaction
# • Chapter 6, Optimizing Continuous Functions

# Distributed Evolutionary Algorithms in Python (DEAP) - a powerful and flexible evolutionary computation framework
# capable of solving real-life problems using genetic algorithms. 
#  (Other frameworks PyGAD, GAFT, Pyevolve, and PyGMO)

# DEAP is a Python framework that supports the rapid development of solutions using genetic algorithms,
# as well as other evolutionary computation techniques. DEAP offers various data structures and tools
# that prove essential when implementing a wide range of genetic-algorithm-based solutions.

# Използване на модула creator

# Първият мощен инструмент, предоставен от DEAP, е модулът creator. Той действа като мета-фабрика, която ни позволява да разширяваме
# съществуващи класове, като им добавяме нови атрибути.

# Пример за използване:
# Да предположим, че имаме клас, наречен Employee. С помощта на creator можем да разширим този клас, създавайки нов клас Developer:

"""
from deap import creator
creator.create("Developer", Employee, 
               position="Developer", 
               programmingLanguages=set)
"""

# Параметри на create():
# Първият аргумент е името на новия клас (тук: "Developer").
# Вторият аргумент е съществуващият базов клас, който ще бъде разширен (тук: Employee).
# Всеки следващ аргумент дефинира атрибут за новия клас:
# Ако аргументът е структура от данни (като dict или set), той се добавя като атрибут на инстанцията, инициализиран в конструктора.
# Ако аргументът е прост тип (като литерал), той се добавя като класов атрибут, споделян между всички инстанции на класа.
# Резултат:
# Създаденият клас Developer ще разширява класа Employee и ще има:

# Класов атрибут position, зададен на "Developer".
# Атрибут на инстанцията programmingLanguages от тип set, инициализиран в конструктора.
# Еквивалентен клас на създадения с creator:

"""
class Developer(Employee):
    position = "Developer"
    def __init__(self):
        self.programmingLanguages = set()
"""

# Важни бележки:
# Новият клас съществува в модула creator и трябва да бъде рефериран като creator.Developer.
# Разширяването на класа numpy.ndarray е специален случай, който ще бъде обсъден по-късно в книгата.
# Основна употреба в DEAP:
# Модулът creator обикновено се използва за създаване на:

# Клас Fitness, който дефинира функцията за годност.
# Клас Individual, който дефинира индивидите за генетичния алгоритъм.

# Създаване на класа Fitness

# В DEAP стойностите на годността (fitness values) са капсулирани в клас, наречен Fitness. Този клас позволява годността да бъде
# комбинирана в няколко компонента (наречени цели), всяка със собствено тегло. Комбинацията от тези тегла определя стратегията за
# годността при даден проблем.

# Дефиниране на стратегията за годност
# DEAP предоставя абстрактния клас base.Fitness, който съдържа атрибута weights.

# weights е кортеж, който трябва да бъде зададен, за да се определи стратегията за годност и да се направи класът използваем.
# Това се постига чрез разширяване на base.Fitness, използвайки модула creator.
# Пример 1: Максимизираща стратегия

from deap import creator, base
creator.create("FitnessMax", base.Fitness, weights=(1.0,))

# Това създава класа creator.FitnessMax, който разширява base.Fitness.
# Атрибутът weights е инициализиран с (1.0,).
# Важно: Когато задаваме единично тегло, запетаята в (1.0,) е задължителна, тъй като weights е кортеж.
# Стратегия: Целта е да се максимизират стойностите на годността в задачи с една цел.
# Пример 2: Минимизираща стратегия

creator.create("FitnessMin", base.Fitness, weights=(-1.0,))

# Тази стратегия е за минимизиране на стойностите на годността. Вижте, че теглото е -1.0.

# Мултиобективна стратегия
# Можем да дефинираме клас за оптимизация на повече от една цел с различна степен на важност.

# Пример:
creator.create("FitnessCompound", base.Fitness, weights=(1.0, 0.2, -0.5))

# Това създава класа creator.FitnessCompound, който използва три компонента на годността.
# Тегла:
# Първият компонент има тегло 1.0 → най-важен.
# Вторият компонент има тегло 0.2 → по-малко важен.
# Третият компонент има тегло -0.5 → тенденция към минимизация.
# Стратегия:
# Максимизира първия и втория компонент.
# Минимизира третия компонент.

# Съхраняване на стойностите на годността

# Докато кортежът weights определя стратегията за годност, съответстващ кортеж, наречен values, се използва за съхранение 
# на действителните стойности на годността в класа base.Fitness. Тези стойности се получават от външно дефинирана функция,
# обикновено наречена evaluate(), която ще бъде описана по-късно в тази глава. Точно както кортежът weights, кортежът values
# съдържа една стойност за всяка компонентна цел (objective).

# Трети кортеж, наречен wvalues, съдържа теглените стойности, които се изчисляват чрез умножение на всяка компонентна стойност
# от values със съответстващата ѝ стойност от weights. Всеки път, когато стойностите на годността на дадена инстанция се задават,
# теглените стойности се изчисляват и записват в wvalues. Тези теглени стойности се използват вътрешно за операции на сравнение
# между индивиди.

# Теглените стойности на годността могат да бъдат лексикографски сравнени чрез следните оператори:
# >, <, >=, <=, ==, !=

# След като класът Fitness бъде създаден, той може да бъде използван в дефиницията на класа Individual, както е показано в 
# следващата подсекция.


# Създаване на класа Individual

# Второто често срещано приложение на инструмента creator в DEAP е дефинирането на индивидите, които формират популацията
# за генетичния алгоритъм. Както видяхме в предишните глави, индивидите в генетичните алгоритми се представят чрез хромозома,
# която може да бъде манипулирана от генетични оператори.

# В DEAP класът Individual се създава чрез разширяване на базов клас, който представлява хромозомата. Освен това, всяка инстанция 
# в DEAP трябва да съдържа функцията за годност (fitness function) като атрибут.

# За да изпълним тези две изисквания, можем да използваме creator, за да създадем класа creator.Individual, както е показано в примера:

creator.create("Individual", list, fitness=creator.FitnessMax)

# Тази линия постига следните две цели:

# Създаденият клас Individual разширява Python класа list. Това означава, че хромозомата, която се използва, е от тип list.
# Всяка инстанция на този клас Individual ще има атрибут, наречен fitness, от класа FitnessMax, който създадохме по-рано.

page = 74/51




