# This part contains the following chapters:
# • Chapter 3, Using the DEAP Framework
# • Chapter 4, Combinatorial Optimization
# • Chapter 5, Constraint Satisfaction
# • Chapter 6, Optimizing Continuous Functions

# Distributed Evolutionary Algorithms in Python (DEAP) - a powerful and flexible evolutionary computation framework
# capable of solving real-life problems using genetic algorithms. 
#  (Other frameworks PyGAD, GAFT, Pyevolve, and PyGMO)

# DEAP is a Python framework that supports the rapid development of solutions using genetic algorithms,
# as well as other evolutionary computation techniques. DEAP offers various data structures and tools
# that prove essential when implementing a wide range of genetic-algorithm-based solutions.

# Използване на модула creator

# Първият мощен инструмент, предоставен от DEAP, е модулът creator. Той действа като мета-фабрика, която ни позволява да разширяваме
# съществуващи класове, като им добавяме нови атрибути.

# Пример за използване:
# Да предположим, че имаме клас, наречен Employee. С помощта на creator можем да разширим този клас, създавайки нов клас Developer:

"""
from deap import creator
creator.create("Developer", Employee, 
               position="Developer", 
               programmingLanguages=set)
"""

# Параметри на create():
# Първият аргумент е името на новия клас (тук: "Developer").
# Вторият аргумент е съществуващият базов клас, който ще бъде разширен (тук: Employee).
# Всеки следващ аргумент дефинира атрибут за новия клас:
# Ако аргументът е структура от данни (като dict или set), той се добавя като атрибут на инстанцията, инициализиран в конструктора.
# Ако аргументът е прост тип (като литерал), той се добавя като класов атрибут, споделян между всички инстанции на класа.
# Резултат:
# Създаденият клас Developer ще разширява класа Employee и ще има:

# Класов атрибут position, зададен на "Developer".
# Атрибут на инстанцията programmingLanguages от тип set, инициализиран в конструктора.
# Еквивалентен клас на създадения с creator:

"""
class Developer(Employee):
    position = "Developer"
    def __init__(self):
        self.programmingLanguages = set()
"""

# Важни бележки:
# Новият клас съществува в модула creator и трябва да бъде рефериран като creator.Developer.
# Разширяването на класа numpy.ndarray е специален случай, който ще бъде обсъден по-късно в книгата.
# Основна употреба в DEAP:
# Модулът creator обикновено се използва за създаване на:

# Клас Fitness, който дефинира функцията за годност.
# Клас Individual, който дефинира индивидите за генетичния алгоритъм.

# Създаване на класа Fitness

# В DEAP стойностите на годността (fitness values) са капсулирани в клас, наречен Fitness. Този клас позволява годността да бъде
# комбинирана в няколко компонента (наречени цели), всяка със собствено тегло. Комбинацията от тези тегла определя стратегията за
# годността при даден проблем.

# Дефиниране на стратегията за годност
# DEAP предоставя абстрактния клас base.Fitness, който съдържа атрибута weights.

# weights е кортеж, който трябва да бъде зададен, за да се определи стратегията за годност и да се направи класът използваем.
# Това се постига чрез разширяване на base.Fitness, използвайки модула creator.
# Пример 1: Максимизираща стратегия

from deap import creator, base
creator.create("FitnessMax", base.Fitness, weights=(1.0,))

# Това създава класа creator.FitnessMax, който разширява base.Fitness.
# Атрибутът weights е инициализиран с (1.0,).
# Важно: Когато задаваме единично тегло, запетаята в (1.0,) е задължителна, тъй като weights е кортеж.
# Стратегия: Целта е да се максимизират стойностите на годността в задачи с една цел.
# Пример 2: Минимизираща стратегия

creator.create("FitnessMin", base.Fitness, weights=(-1.0,))

# Тази стратегия е за минимизиране на стойностите на годността. Вижте, че теглото е -1.0.

# Мултиобективна стратегия
# Можем да дефинираме клас за оптимизация на повече от една цел с различна степен на важност.

# Пример:
creator.create("FitnessCompound", base.Fitness, weights=(1.0, 0.2, -0.5))

# Това създава класа creator.FitnessCompound, който използва три компонента на годността.
# Тегла:
# Първият компонент има тегло 1.0 → най-важен.
# Вторият компонент има тегло 0.2 → по-малко важен.
# Третият компонент има тегло -0.5 → тенденция към минимизация.
# Стратегия:
# Максимизира първия и втория компонент.
# Минимизира третия компонент.

# Съхраняване на стойностите на годността

# Докато кортежът weights определя стратегията за годност, съответстващ кортеж, наречен values, се използва за съхранение 
# на действителните стойности на годността в класа base.Fitness. Тези стойности се получават от външно дефинирана функция,
# обикновено наречена evaluate(), която ще бъде описана по-късно в тази глава. Точно както кортежът weights, кортежът values
# съдържа една стойност за всяка компонентна цел (objective).

# Трети кортеж, наречен wvalues, съдържа теглените стойности, които се изчисляват чрез умножение на всяка компонентна стойност
# от values със съответстващата ѝ стойност от weights. Всеки път, когато стойностите на годността на дадена инстанция се задават,
# теглените стойности се изчисляват и записват в wvalues. Тези теглени стойности се използват вътрешно за операции на сравнение
# между индивиди.

# Теглените стойности на годността могат да бъдат лексикографски сравнени чрез следните оператори:
# >, <, >=, <=, ==, !=

# След като класът Fitness бъде създаден, той може да бъде използван в дефиницията на класа Individual, както е показано в 
# следващата подсекция.


# Създаване на класа Individual

# Второто често срещано приложение на инструмента creator в DEAP е дефинирането на индивидите, които формират популацията
# за генетичния алгоритъм. Както видяхме в предишните глави, индивидите в генетичните алгоритми се представят чрез хромозома,
# която може да бъде манипулирана от генетични оператори.

# В DEAP класът Individual се създава чрез разширяване на базов клас, който представлява хромозомата. Освен това, всяка инстанция 
# в DEAP трябва да съдържа функцията за годност (fitness function) като атрибут.

# За да изпълним тези две изисквания, можем да използваме creator, за да създадем класа creator.Individual, както е показано в примера:

creator.create("Individual", list, fitness=creator.FitnessMax)

# Тази линия постига следните две цели:

# Създаденият клас Individual разширява Python класа list. Това означава, че хромозомата, която се използва, е от тип list.
# Всяка инстанция на този клас Individual ще има атрибут, наречен fitness, от класа FitnessMax, който създадохме по-рано.

# page = 74/51

# Използване на класа Toolbox

# Вторият механизъм, предоставен от DEAP, е класът base.Toolbox. Toolbox се използва като контейнер за функции (или оператори)
# и ни позволява да създаваме нови оператори чрез задаване на псевдоними и персонализиране на съществуващи функции.

# Пример:
# Да предположим, че имаме функция sumOfTwo() с дефиниция:

def sumOfTwo(a, b):
    return a + b

from deap import base

toolbox = base.Toolbox()
toolbox.register("incrementByFive", sumOfTwo, b=5)

# Обяснение на параметрите в register():
# Първи аргумент: Името (или псевдонимът) на новия оператор, в този случай "incrementByFive".
# Втори аргумент: Съществуващата функция, която се персонализира, в случая sumOfTwo.
# Допълнителни аргументи: Всички следващи (по избор) аргументи се подават автоматично към персонализираната функция
# всеки път, когато извикаме новия оператор.

# Как работи операторът:
# Извикването на:

toolbox.incrementByFive(10)

sumOfTwo(10, 5)

# Това е така, защото аргументът b е фиксиран със стойност 5 при дефинирането на оператора incrementByFive.
# Toolbox предоставя удобен начин за създаване и използване на персонализирани функции и оператори, което значително 
# улеснява работата с генетични алгоритми.

# Създаване на генетични оператори

# Класът Toolbox често се използва за персонализиране на съществуващи функции от модула tools. Този модул съдържа 
# множество полезни функции, свързани с генетичните операции по селекция, кръстосване и мутация, както и за инициализация.

# Пример за дефиниране на оператори:
# Следният код дефинира три псевдонима, които по-късно ще бъдат използвани като генетични оператори:

from deap import tools

toolbox.register("select", tools.selTournament, tournsize=3)
toolbox.register("mate", tools.cxTwoPoint)
toolbox.register("mutate", tools.mutFlipBit, indpb=0.02)

# Дефинирани псевдоними:

# select:

# Регистриран като псевдоним за съществуващата функция tools.selTournament().
# Параметърът tournsize е зададен на 3, създавайки оператор toolbox.select, който изпълнява турнирна селекция с размер на турнира 3.
# mate:

# Регистриран като псевдоним за съществуващата функция tools.cxTwoPoint().
# Резултатът е оператор toolbox.mate, който извършва кръстосване с две точки.
# mutate:

# Регистриран като псевдоним за съществуващата функция tools.mutFlipBit.
# Параметърът indpb е зададен на 0.02, което създава оператор toolbox.mutate, изпълняващ мутация чрез обръщане на бит с 
# вероятност от 0.02 за всяка характеристика да бъде обърната.
# Функции в модула tools:
# Селекция (selection.py):
# selRoulette(): Реализира селекция с рулетка.
# selStochasticUniversalSampling(): Реализира стохастично универсално семплиране (SUS).
# selTournament(): Реализира турнирна селекция.
# Кръстосване (crossover.py):
# cxOnePoint(): Реализира кръстосване с една точка.
# cxUniform(): Реализира униформено кръстосване.
# cxOrdered(): Реализира подредено кръстосване (OX1).
# cxPartialyMatched(): Реализира частично съвпадащо кръстосване (PMX).
# Мутация (mutation.py):
# mutFlipBit(): Реализира мутация чрез обръщане на бит.
# mutGaussian(): Реализира мутация с нормално разпределение.
# Модулът tools предоставя гъвкави и готови за използване имплементации на различни генетични оператори.

# Създаване на популация

# Файлът init.py от модула tools съдържа няколко функции, полезни за създаване и инициализиране на популацията за генетичния 
# алгоритъм. Една особено полезна функция е initRepeat(), която приема три аргумента:

# Тип на контейнера: Типът на структурата, в която ще бъдат поставени генерираните обекти.
# Генерираща функция: Функцията, използвана за създаване на обектите, които ще бъдат поставени в контейнера.
# Брой обекти: Броят на обектите, които искаме да генерираме.
# Пример:
# Следният код ще създаде списък от 30 случайни числа между 0 и 1:
import random

randomList = tools.initRepeat(list, random.random, 30)

# Обяснение:
# list е типът на контейнера, който ще бъде запълнен.
# random.random е функцията, която генерира случайни числа между 0 и 1.
# 30 е броят на генерираните стойности.

# Генериране на цели числа 0 или 1:
# Ако искаме да запълним списъка със случайни цели числа (0 или 1), можем да създадем функция, която използва random.randint()
# за генериране на тези стойности, както е показано тук:

def zeroOrOne():
    return random.randint(0, 1)

randomList = tools.initRepeat(list, zeroOrOne, 30)

# Използване на Toolbox:
# Същото може да бъде постигнато по-ефективно чрез toolbox:

toolbox.register("zeroOrOne", random.randint, 0, 1)
randomList = tools.initRepeat(list, toolbox.zeroOrOne, 30)

# Обяснение:
# Вместо да дефинираме функцията zeroOrOne() експлицитно, създаваме оператор zeroOrOne (или псевдоним), който извиква
# random.randint() с фиксирани параметри 0 и 1.
# След това използваме този оператор като генератор за функцията initRepeat().
# Функцията initRepeat() е гъвкав инструмент за инициализиране на популации в генетичните алгоритми.

# Изчисляване на годността (Fitness Calculation)

# Както беше споменато по-рано, докато класът Fitness определя теглата на годността, които задават стратегията му
# (като максимизация или минимизация), действителните стойности на годността се изчисляват чрез отделно дефинирана функция.

# Регистриране на функция за изчисление на годността:
# Функцията за изчисляване на годността обикновено се регистрира в модула toolbox с псевдонима evaluate, както е
# показано в следния пример:

_some_calculation_of_the_fitness = 0

def someFitnessCalculationFunction(individual):
    return _some_calculation_of_the_fitness

toolbox.register("evaluate", someFitnessCalculationFunction)

# Обяснение:
# someFitnessCalculationFunction() е функцията, която изчислява годността за даден индивид.
# evaluate е псевдонимът, с който функцията се регистрира в toolbox.
# Какво следва:
# Вече сме готови да приложим наученото и да решим първия си проблем, използвайки генетичен алгоритъм, написан с DEAP.
# Това ще бъде разгледано в следващата секция.


# Задачата OneMax

# Задачата OneMax е проста оптимизационна задача, която често се използва като "Hello World" пример за рамките за 
# генетични алгоритми. В тази глава ще използваме тази задача, за да демонстрираме как DEAP може да бъде използван за
# реализиране на генетичен алгоритъм.

# Описание на задачата:
# Целта на OneMax е да се намери бинарен низ с дадена дължина, който максимизира сумата на своите цифри.

# Пример:
# За задача OneMax с дължина 5, могат да се разглеждат следните кандидати:

# 10010 (сума на цифрите = 2)
# 01110 (сума на цифрите = 3)
# 11111 (сума на цифрите = 5)
# Очевидно е, че решението на тази задача винаги е низ, състоящ се изцяло от единици (111...1).

# Генетичен подход:
# Въпреки че решението е очевидно за нас, генетичният алгоритъм няма тази предварителна информация и трябва "сляпо" да намери 
# решението, използвайки своите генетични оператори. Ако алгоритъмът работи правилно, той ще открие решението (или близко до него) 
# в рамките на разумно време.

# OneMax в документацията на DEAP:
# Документацията на DEAP използва OneMax като въвеждащ пример:
# DEAP OneMax пример.

# Решаване на задачата OneMax с DEAP

# В предишната глава разгледахме редица избори, които трябва да се направят при решаването на задача с подхода на генетичните алгоритми.
# Докато решаваме задачата OneMax, ще правим тези избори стъпка по стъпка. В следващите глави ще използваме същата последователност
# от стъпки за прилагане на генетичните алгоритми към различни типове задачи.

# Избор на хромозома:
# Тъй като задачата OneMax се занимава с бинарни низове, изборът на хромозома е лесен – всеки индивид ще бъде представен чрез 
# бинарен низ, който директно представлява кандидат-решение.

# Имплементация в Python:
# В Python хромозомата ще бъде реализирана като списък, съдържащ цели числа 0 или 1.
# Дължината на хромозомата съответства на размера на задачата OneMax.
# Пример:
# За задача OneMax с размер 5, индивидът 10010 ще бъде представен като:

# [1, 0, 0, 1, 0]

# Изчисляване на годността (fitness)

# Тъй като целта на задачата OneMax е да намерим индивида с най-голяма сума на цифрите, ще използваме стратегията FitnessMax.

# Метод за изчисление на годността:
# Всеки индивид е представен като списък от цели числа 0 или 1.
# Стойността на годността се изчислява директно като сумата на елементите в списъка.
# Пример:
# За индивида [1, 0, 0, 1, 0]:

sum([1, 0, 0, 1, 0]) = 2

# Този подход осигурява проста, но ефективна метрика за годност, която генетичният алгоритъм ще оптимизира.

# page 55/ 78

# Общи съображения:
# Селекция: Повечето оператори за селекция могат да работят с всякакъв тип хромозоми.
# Кръстосване и мутация: Тези оператори трябва да съответстват на типа хромозома, който използваме. В противен случай могат да
#  генерират невалидни хромозоми.
# Избор на оператори за задачата OneMax:
# Селекция:

# Избираме турнирна селекция (tournament selection) като начален избор, защото е проста и ефективна.
# По-късно можем да експериментираме с други стратегии, като селекция с рулетка или SUS (Stochastic Universal Sampling).
# Кръстосване:

# Подходящи оператори са едноточково кръстосване (single-point crossover) или двуточково кръстосване (two-point crossover).
# И двата метода гарантират, че резултатът от кръстосването на два бинарни низа ще бъде валиден бинарен низ.
# Мутация:

# Използваме мутация чрез обръщане на бит (flip-bit mutation), която е ефективна за бинарни низове.

# Определяне на условие за спиране

# Добре е винаги да се зададе ограничение за броя на поколенията, за да се гарантира, че алгоритъмът няма да се изпълнява безкрайно.
#  Това представлява едно от условията за спиране.

# Допълнително условие за задачата OneMax:
# Тъй като знаем оптималното решение за задачата OneMax – бинарен низ, състоящ се изцяло от 1, със стойност на годност, равна на 
# дължината на индивида – можем да използваме това като второ условие за спиране.

# Условия за спиране:
# Достигане на максимален брой поколения:
# Това гарантира, че алгоритъмът няма да продължи безкрайно.
# Намиране на оптималното решение:
# Алгоритъмът спира, ако се достигне бинарен низ с всички 1 и годност, равна на дължината на индивида.
# Важно уточнение:
# При реални проблеми обикновено нямаме предварителна информация за най-доброто решение, така че условие като 
# "намиране на оптималното решение" не винаги е приложимо.

# Заключение:
# Алгоритъмът ще спре, ако е изпълнено поне едно от тези условия – достигнат е максималният брой поколения или е намерено
#  най-доброто решение.
