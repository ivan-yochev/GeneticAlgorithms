# This part contains the following chapters:
# • Chapter 3, Using the DEAP Framework
# • Chapter 4, Combinatorial Optimization
# • Chapter 5, Constraint Satisfaction
# • Chapter 6, Optimizing Continuous Functions

# Distributed Evolutionary Algorithms in Python (DEAP) - a powerful and flexible evolutionary computation framework
# capable of solving real-life problems using genetic algorithms. 
#  (Other frameworks PyGAD, GAFT, Pyevolve, and PyGMO)

# DEAP is a Python framework that supports the rapid development of solutions using genetic algorithms,
# as well as other evolutionary computation techniques. DEAP offers various data structures and tools
# that prove essential when implementing a wide range of genetic-algorithm-based solutions.

# Използване на модула creator

# Първият мощен инструмент, предоставен от DEAP, е модулът creator. Той действа като мета-фабрика, която ни позволява да разширяваме
# съществуващи класове, като им добавяме нови атрибути.

# Пример за използване:
# Да предположим, че имаме клас, наречен Employee. С помощта на creator можем да разширим този клас, създавайки нов клас Developer:

"""
from deap import creator
creator.create("Developer", Employee, 
               position="Developer", 
               programmingLanguages=set)
"""

# Параметри на create():
# Първият аргумент е името на новия клас (тук: "Developer").
# Вторият аргумент е съществуващият базов клас, който ще бъде разширен (тук: Employee).
# Всеки следващ аргумент дефинира атрибут за новия клас:
# Ако аргументът е структура от данни (като dict или set), той се добавя като атрибут на инстанцията, инициализиран в конструктора.
# Ако аргументът е прост тип (като литерал), той се добавя като класов атрибут, споделян между всички инстанции на класа.
# Резултат:
# Създаденият клас Developer ще разширява класа Employee и ще има:

# Класов атрибут position, зададен на "Developer".
# Атрибут на инстанцията programmingLanguages от тип set, инициализиран в конструктора.
# Еквивалентен клас на създадения с creator:

"""
class Developer(Employee):
    position = "Developer"
    def __init__(self):
        self.programmingLanguages = set()
"""

# Важни бележки:
# Новият клас съществува в модула creator и трябва да бъде рефериран като creator.Developer.
# Разширяването на класа numpy.ndarray е специален случай, който ще бъде обсъден по-късно в книгата.
# Основна употреба в DEAP:
# Модулът creator обикновено се използва за създаване на:

# Клас Fitness, който дефинира функцията за годност.
# Клас Individual, който дефинира индивидите за генетичния алгоритъм.

# Създаване на класа Fitness

# В DEAP стойностите на годността (fitness values) са капсулирани в клас, наречен Fitness. Този клас позволява годността да бъде
# комбинирана в няколко компонента (наречени цели), всяка със собствено тегло. Комбинацията от тези тегла определя стратегията за
# годността при даден проблем.

# Дефиниране на стратегията за годност
# DEAP предоставя абстрактния клас base.Fitness, който съдържа атрибута weights.

# weights е кортеж, който трябва да бъде зададен, за да се определи стратегията за годност и да се направи класът използваем.
# Това се постига чрез разширяване на base.Fitness, използвайки модула creator.
# Пример 1: Максимизираща стратегия

from deap import creator, base
creator.create("FitnessMax", base.Fitness, weights=(1.0,))

# Това създава класа creator.FitnessMax, който разширява base.Fitness.
# Атрибутът weights е инициализиран с (1.0,).
# Важно: Когато задаваме единично тегло, запетаята в (1.0,) е задължителна, тъй като weights е кортеж.
# Стратегия: Целта е да се максимизират стойностите на годността в задачи с една цел.
# Пример 2: Минимизираща стратегия

creator.create("FitnessMin", base.Fitness, weights=(-1.0,))

# Тази стратегия е за минимизиране на стойностите на годността. Вижте, че теглото е -1.0.

# Мултиобективна стратегия
# Можем да дефинираме клас за оптимизация на повече от една цел с различна степен на важност.

# Пример:
creator.create("FitnessCompound", base.Fitness, weights=(1.0, 0.2, -0.5))

# Това създава класа creator.FitnessCompound, който използва три компонента на годността.
# Тегла:
# Първият компонент има тегло 1.0 → най-важен.
# Вторият компонент има тегло 0.2 → по-малко важен.
# Третият компонент има тегло -0.5 → тенденция към минимизация.
# Стратегия:
# Максимизира първия и втория компонент.
# Минимизира третия компонент.

# Съхраняване на стойностите на годността

# Докато кортежът weights определя стратегията за годност, съответстващ кортеж, наречен values, се използва за съхранение 
# на действителните стойности на годността в класа base.Fitness. Тези стойности се получават от външно дефинирана функция,
# обикновено наречена evaluate(), която ще бъде описана по-късно в тази глава. Точно както кортежът weights, кортежът values
# съдържа една стойност за всяка компонентна цел (objective).

# Трети кортеж, наречен wvalues, съдържа теглените стойности, които се изчисляват чрез умножение на всяка компонентна стойност
# от values със съответстващата ѝ стойност от weights. Всеки път, когато стойностите на годността на дадена инстанция се задават,
# теглените стойности се изчисляват и записват в wvalues. Тези теглени стойности се използват вътрешно за операции на сравнение
# между индивиди.

# Теглените стойности на годността могат да бъдат лексикографски сравнени чрез следните оператори:
# >, <, >=, <=, ==, !=

# След като класът Fitness бъде създаден, той може да бъде използван в дефиницията на класа Individual, както е показано в 
# следващата подсекция.


# Създаване на класа Individual

# Второто често срещано приложение на инструмента creator в DEAP е дефинирането на индивидите, които формират популацията
# за генетичния алгоритъм. Както видяхме в предишните глави, индивидите в генетичните алгоритми се представят чрез хромозома,
# която може да бъде манипулирана от генетични оператори.

# В DEAP класът Individual се създава чрез разширяване на базов клас, който представлява хромозомата. Освен това, всяка инстанция 
# в DEAP трябва да съдържа функцията за годност (fitness function) като атрибут.

# За да изпълним тези две изисквания, можем да използваме creator, за да създадем класа creator.Individual, както е показано в примера:

creator.create("Individual", list, fitness=creator.FitnessMax)

# Тази линия постига следните две цели:

# Създаденият клас Individual разширява Python класа list. Това означава, че хромозомата, която се използва, е от тип list.
# Всяка инстанция на този клас Individual ще има атрибут, наречен fitness, от класа FitnessMax, който създадохме по-рано.

# page = 74/51

# Използване на класа Toolbox

# Вторият механизъм, предоставен от DEAP, е класът base.Toolbox. Toolbox се използва като контейнер за функции (или оператори)
# и ни позволява да създаваме нови оператори чрез задаване на псевдоними и персонализиране на съществуващи функции.

# Пример:
# Да предположим, че имаме функция sumOfTwo() с дефиниция:

def sumOfTwo(a, b):
    return a + b

from deap import base

toolbox = base.Toolbox()
toolbox.register("incrementByFive", sumOfTwo, b=5)

# Обяснение на параметрите в register():
# Първи аргумент: Името (или псевдонимът) на новия оператор, в този случай "incrementByFive".
# Втори аргумент: Съществуващата функция, която се персонализира, в случая sumOfTwo.
# Допълнителни аргументи: Всички следващи (по избор) аргументи се подават автоматично към персонализираната функция
# всеки път, когато извикаме новия оператор.

# Как работи операторът:
# Извикването на:

toolbox.incrementByFive(10)

sumOfTwo(10, 5)

# Това е така, защото аргументът b е фиксиран със стойност 5 при дефинирането на оператора incrementByFive.
# Toolbox предоставя удобен начин за създаване и използване на персонализирани функции и оператори, което значително 
# улеснява работата с генетични алгоритми.

# Създаване на генетични оператори

# Класът Toolbox често се използва за персонализиране на съществуващи функции от модула tools. Този модул съдържа 
# множество полезни функции, свързани с генетичните операции по селекция, кръстосване и мутация, както и за инициализация.

# Пример за дефиниране на оператори:
# Следният код дефинира три псевдонима, които по-късно ще бъдат използвани като генетични оператори:

from deap import tools

toolbox.register("select", tools.selTournament, tournsize=3)
toolbox.register("mate", tools.cxTwoPoint)
toolbox.register("mutate", tools.mutFlipBit, indpb=0.02)

# Дефинирани псевдоними:

# select:

# Регистриран като псевдоним за съществуващата функция tools.selTournament().
# Параметърът tournsize е зададен на 3, създавайки оператор toolbox.select, който изпълнява турнирна селекция с размер на турнира 3.
# mate:

# Регистриран като псевдоним за съществуващата функция tools.cxTwoPoint().
# Резултатът е оператор toolbox.mate, който извършва кръстосване с две точки.
# mutate:

# Регистриран като псевдоним за съществуващата функция tools.mutFlipBit.
# Параметърът indpb е зададен на 0.02, което създава оператор toolbox.mutate, изпълняващ мутация чрез обръщане на бит с 
# вероятност от 0.02 за всяка характеристика да бъде обърната.
# Функции в модула tools:
# Селекция (selection.py):
# selRoulette(): Реализира селекция с рулетка.
# selStochasticUniversalSampling(): Реализира стохастично универсално семплиране (SUS).
# selTournament(): Реализира турнирна селекция.
# Кръстосване (crossover.py):
# cxOnePoint(): Реализира кръстосване с една точка.
# cxUniform(): Реализира униформено кръстосване.
# cxOrdered(): Реализира подредено кръстосване (OX1).
# cxPartialyMatched(): Реализира частично съвпадащо кръстосване (PMX).
# Мутация (mutation.py):
# mutFlipBit(): Реализира мутация чрез обръщане на бит.
# mutGaussian(): Реализира мутация с нормално разпределение.
# Модулът tools предоставя гъвкави и готови за използване имплементации на различни генетични оператори.

# Създаване на популация

# Файлът init.py от модула tools съдържа няколко функции, полезни за създаване и инициализиране на популацията за генетичния 
# алгоритъм. Една особено полезна функция е initRepeat(), която приема три аргумента:

# Тип на контейнера: Типът на структурата, в която ще бъдат поставени генерираните обекти.
# Генерираща функция: Функцията, използвана за създаване на обектите, които ще бъдат поставени в контейнера.
# Брой обекти: Броят на обектите, които искаме да генерираме.
# Пример:
# Следният код ще създаде списък от 30 случайни числа между 0 и 1:
import random

randomList = tools.initRepeat(list, random.random, 30)

# Обяснение:
# list е типът на контейнера, който ще бъде запълнен.
# random.random е функцията, която генерира случайни числа между 0 и 1.
# 30 е броят на генерираните стойности.

# Генериране на цели числа 0 или 1:
# Ако искаме да запълним списъка със случайни цели числа (0 или 1), можем да създадем функция, която използва random.randint()
# за генериране на тези стойности, както е показано тук:

def zeroOrOne():
    return random.randint(0, 1)

randomList = tools.initRepeat(list, zeroOrOne, 30)

# Използване на Toolbox:
# Същото може да бъде постигнато по-ефективно чрез toolbox:

toolbox.register("zeroOrOne", random.randint, 0, 1)
randomList = tools.initRepeat(list, toolbox.zeroOrOne, 30)

# Обяснение:
# Вместо да дефинираме функцията zeroOrOne() експлицитно, създаваме оператор zeroOrOne (или псевдоним), който извиква
# random.randint() с фиксирани параметри 0 и 1.
# След това използваме този оператор като генератор за функцията initRepeat().
# Функцията initRepeat() е гъвкав инструмент за инициализиране на популации в генетичните алгоритми.

# Изчисляване на годността (Fitness Calculation)

# Както беше споменато по-рано, докато класът Fitness определя теглата на годността, които задават стратегията му
# (като максимизация или минимизация), действителните стойности на годността се изчисляват чрез отделно дефинирана функция.

# Регистриране на функция за изчисление на годността:
# Функцията за изчисляване на годността обикновено се регистрира в модула toolbox с псевдонима evaluate, както е
# показано в следния пример:

_some_calculation_of_the_fitness = 0

def someFitnessCalculationFunction(individual):
    return _some_calculation_of_the_fitness

toolbox.register("evaluate", someFitnessCalculationFunction)

# Обяснение:
# someFitnessCalculationFunction() е функцията, която изчислява годността за даден индивид.
# evaluate е псевдонимът, с който функцията се регистрира в toolbox.
# Какво следва:
# Вече сме готови да приложим наученото и да решим първия си проблем, използвайки генетичен алгоритъм, написан с DEAP.
# Това ще бъде разгледано в следващата секция.


# Задачата OneMax

# Задачата OneMax е проста оптимизационна задача, която често се използва като "Hello World" пример за рамките за 
# генетични алгоритми. В тази глава ще използваме тази задача, за да демонстрираме как DEAP може да бъде използван за
# реализиране на генетичен алгоритъм.

# Описание на задачата:
# Целта на OneMax е да се намери бинарен низ с дадена дължина, който максимизира сумата на своите цифри.

# Пример:
# За задача OneMax с дължина 5, могат да се разглеждат следните кандидати:

# 10010 (сума на цифрите = 2)
# 01110 (сума на цифрите = 3)
# 11111 (сума на цифрите = 5)
# Очевидно е, че решението на тази задача винаги е низ, състоящ се изцяло от единици (111...1).

# Генетичен подход:
# Въпреки че решението е очевидно за нас, генетичният алгоритъм няма тази предварителна информация и трябва "сляпо" да намери 
# решението, използвайки своите генетични оператори. Ако алгоритъмът работи правилно, той ще открие решението (или близко до него) 
# в рамките на разумно време.

# OneMax в документацията на DEAP:
# Документацията на DEAP използва OneMax като въвеждащ пример:
# DEAP OneMax пример.

# Решаване на задачата OneMax с DEAP

# В предишната глава разгледахме редица избори, които трябва да се направят при решаването на задача с подхода на генетичните алгоритми.
# Докато решаваме задачата OneMax, ще правим тези избори стъпка по стъпка. В следващите глави ще използваме същата последователност
# от стъпки за прилагане на генетичните алгоритми към различни типове задачи.

# Избор на хромозома:
# Тъй като задачата OneMax се занимава с бинарни низове, изборът на хромозома е лесен – всеки индивид ще бъде представен чрез 
# бинарен низ, който директно представлява кандидат-решение.

# Имплементация в Python:
# В Python хромозомата ще бъде реализирана като списък, съдържащ цели числа 0 или 1.
# Дължината на хромозомата съответства на размера на задачата OneMax.
# Пример:
# За задача OneMax с размер 5, индивидът 10010 ще бъде представен като:

# [1, 0, 0, 1, 0]

# Изчисляване на годността (fitness)

# Тъй като целта на задачата OneMax е да намерим индивида с най-голяма сума на цифрите, ще използваме стратегията FitnessMax.

# Метод за изчисление на годността:
# Всеки индивид е представен като списък от цели числа 0 или 1.
# Стойността на годността се изчислява директно като сумата на елементите в списъка.
# Пример:
# За индивида [1, 0, 0, 1, 0]:

sum([1, 0, 0, 1, 0]) = 2

# Този подход осигурява проста, но ефективна метрика за годност, която генетичният алгоритъм ще оптимизира.

# page 55/ 78

# Общи съображения:
# Селекция: Повечето оператори за селекция могат да работят с всякакъв тип хромозоми.
# Кръстосване и мутация: Тези оператори трябва да съответстват на типа хромозома, който използваме. В противен случай могат да
#  генерират невалидни хромозоми.
# Избор на оператори за задачата OneMax:
# Селекция:

# Избираме турнирна селекция (tournament selection) като начален избор, защото е проста и ефективна.
# По-късно можем да експериментираме с други стратегии, като селекция с рулетка или SUS (Stochastic Universal Sampling).
# Кръстосване:

# Подходящи оператори са едноточково кръстосване (single-point crossover) или двуточково кръстосване (two-point crossover).
# И двата метода гарантират, че резултатът от кръстосването на два бинарни низа ще бъде валиден бинарен низ.
# Мутация:

# Използваме мутация чрез обръщане на бит (flip-bit mutation), която е ефективна за бинарни низове.

# Определяне на условие за спиране

# Добре е винаги да се зададе ограничение за броя на поколенията, за да се гарантира, че алгоритъмът няма да се изпълнява безкрайно.
#  Това представлява едно от условията за спиране.

# Допълнително условие за задачата OneMax:
# Тъй като знаем оптималното решение за задачата OneMax – бинарен низ, състоящ се изцяло от 1, със стойност на годност, равна на 
# дължината на индивида – можем да използваме това като второ условие за спиране.

# Условия за спиране:
# Достигане на максимален брой поколения:
# Това гарантира, че алгоритъмът няма да продължи безкрайно.
# Намиране на оптималното решение:
# Алгоритъмът спира, ако се достигне бинарен низ с всички 1 и годност, равна на дължината на индивида.
# Важно уточнение:
# При реални проблеми обикновено нямаме предварителна информация за най-доброто решение, така че условие като 
# "намиране на оптималното решение" не винаги е приложимо.

# Заключение:
# Алгоритъмът ще спре, ако е изпълнено поне едно от тези условия – достигнат е максималният брой поколения или е намерено
#  най-доброто решение.

# Using built-in algorithms

# Използване на вградени алгоритми

# Рамката DEAP предоставя няколко вградени еволюционни алгоритми в модула algorithms. Един от тях, eaSimple, имплементира потока на
# генетичния алгоритъм, който използвахме, и може да замени голяма част от кода в основния метод.

# Други полезни обекти в DEAP:
# Statistics:

# Обект, който се използва за събиране на статистики за популацията по време на изпълнението на алгоритъма.
# Logbook:

# Обект за съхраняване и отпечатване на информация за изпълнението, като например максималната и средната годност през поколенията.
# Има се предвид : 02_OneMax_short.py

# The Statistics object

# Обектът Statistics

# Първата промяна, която ще направим, е свързана със събирането на статистики. За тази цел ще се възползваме от класа tools.Statistics, 
# предоставен от DEAP. Тази помощна функция ни позволява да създадем статистически обект, използвайки аргумент key, който е функция,
# приложима върху данните, за които се изчисляват статистики.

# 1. Определяне на ключова функция:
# Тъй като данните, които планираме да предоставим, са популацията за всяко поколение, ще зададем key на функция, която извлича 
# стойностите за годност от всеки индивид.

# stats = tools.Statistics(lambda ind: ind.fitness.values)

# Обяснение:
# tools.Statistics:

# Създава обект за събиране на статистика.
# lambda ind: ind.fitness.values:

# Анонимна функция (lambda), която извлича стойностите на годността (fitness.values) за всеки индивид в популацията.
# С този обект ще можем лесно да изчисляваме статистики като максимална, средна и минимална годност за всяко поколение.

# Регистриране на функции за статистически изчисления

# Сега можем да регистрираме различни функции, които ще бъдат прилагани върху стойностите на годността на всяка стъпка. В този пример
# използваме само функциите numpy.max и numpy.mean, но можем да регистрираме и други функции като numpy.min или numpy.std.

# stats.register("max", numpy.max)  # Регистрира максималната стойност
# stats.register("avg", numpy.mean) # Регистрира средната стойност

# Обяснение:
# stats.register:

# Позволява да регистрираме функция за изчисляване на статистики върху извлечените стойности (годност в този случай).
# Функции:

# numpy.max: Изчислява максималната стойност.
# numpy.mean: Изчислява средната стойност.

# Алгоритъмът

# Сега е време за изпълнение на реалния поток на генетичния алгоритъм. Това се реализира чрез едно единствено извикване на метода
# algorithms.eaSimple, който е един от вградените еволюционни алгоритми, предоставени от модула algorithms на DEAP.

# population, logbook = algorithms.eaSimple(
#     population,
#     toolbox,
#     cxpb=P_CROSSOVER,      # Вероятност за кръстосване
#     mutpb=P_MUTATION,      # Вероятност за мутация
#     ngen=MAX_GENERATIONS,  # Брой поколения за изпълнение
#     stats=stats,           # Обектът за статистика
#     verbose=True           # Печат на информация за всяко поколение
# )

# Обяснение на параметрите:
# population:
# Текущата популация, върху която се изпълнява алгоритъмът.
# toolbox:
# Съдържа регистрираните оператори (evaluate, select, mate, mutate).
# cxpb (Crossover Probability):
# Вероятност за прилагане на кръстосване между индивидите.
# mutpb (Mutation Probability):
# Вероятност за прилагане на мутация върху индивидите.
# ngen (Number of Generations):
# Условие за спиране, задаващо броя на поколенията, които алгоритъмът ще изпълни.
# stats:
# Обектът stats за събиране на статистики, регистриран по-рано.
# verbose:
# Ако е True, алгоритъмът ще отпечатва информация за всяко поколение (например максимална и средна годност).
# Важно уточнение:
# Методът algorithms.eaSimple изисква преди това да сме регистрирали операторите (evaluate, select, mate, mutate) в toolbox.
# Условието за спиране се задава чрез параметъра ngen, който указва броя поколения, за които алгоритъмът ще работи.
# Резултати:
# population: Върнатата популация след изпълнението на алгоритъма.
# logbook: Обект, съдържащ събраните статистики и информация за всяко поколение.

# Logbook (дневник)

# След приключването на потока, алгоритъмът връща два обекта:

# population: Последната популация след изпълнението на алгоритъма.
# logbook: Обект, съдържащ събраните статистики по време на изпълнението.
# Извличане на статистики от logbook:
# Можем да извлечем желаните статистики от logbook, използвайки метода select(), за да ги използваме за визуализация, както 
# направихме преди.

# maxFitnessValues, meanFitnessValues = logbook.select("max", "avg")

# Обяснение:
# logbook.select("max", "avg"):

# Извлича стойностите за максималната ("max") и средната ("avg") годност, събрани за всяко поколение.
# maxFitnessValues:

# Списък със стойностите за максималната годност през поколенията.
# meanFitnessValues:

# Списък със стойностите за средната годност през поколенията.

# Стартитаме програмата: 

# Автоматично отпечатване на резултатите

# Тези отпечатвания се генерират автоматично от метода algorithms.eaSimple, в съответствие с начина, по който дефинирахме обекта за 
# статистика, изпратен към него, и поради факта, че аргументът verbose беше зададен на True.

# Разлики с предишната програма:
# Отпечатване за поколение 0:

# Тук има изход за поколение 0, което не беше включено в предишната програма.
# Продължителност на генетичния поток:

# В тази версия потокът продължава до 50-то поколение, тъй като това беше единственото условие за спиране.
# В предишната програма потокът спря на 40-то поколение, защото допълнителното условие за спиране – достигане на най-доброто решение 
# (познато предварително) – беше изпълнено.

# OneMax HOF

# Добавяне на функцията "Зала на славата" (Hall of Fame)

# Една допълнителна характеристика на вградения метод algorithms.eaSimple е възможността да се използва зала на славата 
# (Hall of Fame, HOF).

# Класът HallOfFame, имплементиран в модула tools, може да се използва, за да задържа най-добрите индивиди, които някога са съществували
# в популацията по време на еволюцията.

# Какво прави Hall of Fame?
# Запазва най-добрите индивиди: Дори ако тези индивиди са изгубени в резултат на селекция, кръстосване или мутация, те ще бъдат запазени.
# Постоянно сортиране: Залата на славата е сортирана така, че първият елемент винаги е индивидът с най-добрата стойност на годността, 
# наблюдавана по време на изпълнението.

# Започваме, като дефинираме константа за броя индивиди, които искаме да запазим в залата на славата. Ще добавим този ред към
# секцията за дефиниране на константи:

# HALL_OF_FAME_SIZE = 10

# Точно преди да извикаме алгоритъма eaSimple, ще създадем обект HallOfFame с този размер:

# hof = tools.HallOfFame(HALL_OF_FAME_SIZE)

# Обектът HallOfFame се изпраща като аргумент на алгоритъма eaSimple, който го актуализира вътрешно по време на изпълнението на потока
# на генетичния алгоритъм:

# population, logbook = algorithms.eaSimple(
#     population, toolbox,
#     cxpb=P_CROSSOVER,
#     mutpb=P_MUTATION,
#     ngen=MAX_GENERATIONS,
#     stats=stats,
#     halloffame=hof,
#     verbose=True
# )

# Когато алгоритъмът приключи, можем да използваме атрибута items на обекта HallOfFame, за да получим списък с индивидите, 
# които са включени в залата на славата:

# print("Hall of Fame Individuals = ", *hof.items, sep="\n")
# print("Best Ever Individual = ", hof.items[0])

# Резултатът от отпечатването изглежда по следния начин:

# Най-добрият индивид се състои от всички единици (1s).
# След него са различни индивиди, които имат стойности 0 на различни места.

# Най-добрият индивид е същият, който беше отпечатан първи преди това:

# Best Ever Individual = [1, 1, 1, 1, ..., 0, ..., 1]

# Това показва, че залата на славата успешно запазва най-добрия индивид, наблюдаван по време на изпълнението на алгоритъма.

# Оттук нататък ще използваме тези функции – обекта за статистика и logbook, вградения алгоритъм eaSimple и HallOfFame – във
# всички програми, които създаваме.

# Сега, след като научихме как да използваме вградените алгоритми, ще експериментираме с тях, за да открием разликите между 
# тях и да намерим най-добрия алгоритъм за различни приложения.