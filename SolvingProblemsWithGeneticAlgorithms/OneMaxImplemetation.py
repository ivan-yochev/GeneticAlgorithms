# Подготовка

# Преди да започнем с основния поток на генетичния алгоритъм, трябва да направим първоначалната настройка. Рамката 
# DEAP предлага специфичен начин за това, както е показано в следните стъпки:

# 1. Импортиране на необходимите модули:
# Започваме с импортиране на основните модули на DEAP, заедно с някои полезни библиотеки:

from deap import base      # Основни класове като Toolbox
from deap import creator   # Създаване на класове Fitness и Individual
from deap import tools     # Инструменти за генетични оператори
import random              # Генериране на случайни числа
import matplotlib.pyplot as plt  # За визуализация на резултатите


# Деклариране на константи

# Следващата стъпка е да дефинираме няколко константи, които определят параметрите на задачата и контролират
# поведението на генетичния алгоритъм.

# Код за дефиниране на константи:

# Константи за задачата:
ONE_MAX_LENGTH = 100  # Дължина на бинарния низ, който ще бъде оптимизиран

# Константи за генетичния алгоритъм:
POPULATION_SIZE = 200  # Брой индивиди в популацията
P_CROSSOVER = 0.9      # Вероятност за кръстосване
P_MUTATION = 0.1       # Вероятност за мутация на индивид
MAX_GENERATIONS = 50   # Максимален брой поколения (условие за спиране)

# Настройване на случайността

# Важен аспект на генетичния алгоритъм е използването на вероятност, която въвежда елемент на случайност в поведението му.
# Въпреки това, по време на експериментиране с кода, може да искаме да изпълним един и същ експеримент няколко пъти и да получим
# повторими резултати.

# За да постигнем това, трябва да зададем случайния seed на константна стойност, както е показано:

RANDOM_SEED = 42
random.seed(RANDOM_SEED)

# Съвет:
# На някакъв етап може да решите да премахнете тези редове код, за да позволите на различните изпълнения на алгоритъма да
# произвеждат леко различни резултати.

# Използване на класа Toolbox за създаване на оператора zeroOrOne

# Както видяхме по-рано в тази глава, класът Toolbox е една от основните помощни функции, предоставени от DEAP.
# Той ни позволява да регистрираме нови функции (или оператори), като персонализираме съществуващи функции чрез 
# предварително зададени аргументи.

# Създаване на оператора zeroOrOne:
# В този случай ще използваме Toolbox, за да създадем оператора zeroOrOne, който персонализира функцията random.randint(a, b).

# Функцията random.randint(a, b) обикновено връща случайно цяло число 
# a ≤ N ≤ b. 
# Чрез фиксиране на стойностите на 

# a и b на 0 и 1, операторът zeroOrOne ще връща на случаен принцип 0 или 1, когато бъде извикан.
# Код за създаване на zeroOrOne:

toolbox = base.Toolbox()
toolbox.register("zeroOrOne", random.randint, 0, 1)

# Създаване на класа Fitness

# Следващата стъпка е да създадем класа Fitness. Тъй като задачата има само една цел – максимизиране на сумата от цифрите – ще
# използваме стратегията FitnessMax и ще зададем кортеж weights с една положителна стойност.

# Код за създаване на класа Fitness:

creator.create("FitnessMax", base.Fitness, weights=(1.0,))

# Обяснение:
# FitnessMax:
# Името на новия клас, който създаваме, представляващ стратегия за максимизиране на годността.
# base.Fitness:
# Базовият клас, който разширяваме, за да дефинираме класа FitnessMax.
# weights=(1.0,):
# Кортеж със стойност 
# 1.0
# 1.0, което означава, че целта е да максимизираме годността.
# Важно: Запетаята е задължителна, тъй като weights трябва да бъде кортеж, дори когато съдържа само една стойност.

# Създаване на класа Individual

# В DEAP конвенцията е да се използва клас, наречен Individual, за да представлява всеки от индивидите в популацията. 
# Този клас се създава с помощта на инструмента creator. В нашия случай, list служи като базов клас, който се използва като 
# хромозома на индивида. Класът се допълва с атрибут fitness, инициализиран към класа FitnessMax, който дефинирахме по-рано:

creator.create("Individual", list, fitness=creator.FitnessMax)


# След това трябва да регистрираме оператора individualCreator, който създава инстанция на класа Individual, запълнена със случайни 
# стойности 0 или 1. Това се прави, като използваме предварително дефинирания оператор zeroOrOne. Тази дефиниция използва оператора 
# initRepeat, споменат по-рано, като базов клас. Той може да бъде персонализиран със следните аргументи:

# Класът Individual може да бъде използван като типа на контейнера, в който ще бъдат поставени резултатните обекти.
# Операторът zeroOrOne може да бъде използван като функция за генериране на обекти.
# Константата ONE_MAX_LENGTH може да бъде използвана като броя на обектите, които искаме да генерираме (в момента зададена на 100).
# Тъй като обектите, генерирани от оператора zeroOrOne, са цели числа със случайни стойности 0 или 1, резултатният оператор
# individualCreator ще запълни инстанция на Individual със 100 случайно генерирани стойности от 0 или 1:

toolbox.register("individualCreator", 
                 tools.initRepeat, 
                 creator.Individual, 
                 toolbox.zeroOrOne, ONE_MAX_LENGTH)

# Накрая, трябва да регистрираме оператора populationCreator, който създава списък от индивиди.

# Тази дефиниция също използва оператора initRepeat, със следните аргументи:

# Класът list се използва като типа на контейнера.
# Операторът individualCreator, дефиниран по-рано, се използва като функция за генериране на обектите в списъка.
# Последният аргумент на initRepeat – броят на обектите, които искаме да генерираме – не е зададен тук. Това означава, че при
# използването на оператора populationCreator този аргумент ще бъде очакван и ще се използва за определяне на броя на създадените
# индивиди – с други думи, размера на популацията:

toolbox.register("populationCreator", 
                 tools.initRepeat, 
                 list, toolbox.individualCreator)

# За да улесним изчисляването на годността (или оценката, според терминологията на DEAP), трябва да дефинираме отделна функция, 
# която приема инстанция на класа Individual и връща нейната годност.

# Тук дефинираме функция, наречена oneMaxFitness, която изчислява броя на единиците (1) в индивида. Тъй като индивидът по същество
# е списък със стойности 0 или 1, можем да използваме вградената Python функция sum() за тази цел:

def oneMaxFitness(individual):
    return sum(individual),  # връща кортеж

# Обяснение:
# individual: Инстанция на класа Individual, представляваща индивид.
# sum(individual): Изчислява сумата на елементите в списъка, което е броят на единиците в индивида.
# Запетаята в края: Указва, че функцията връща кортеж (изискване на DEAP за стойностите на годността).

# Съвет
# Както беше споменато по-рано, стойностите на годността в DEAP се представят като кортежи. Следователно, когато функцията връща
# само една стойност, трябва да добавим запетая след нея, за да я направим кортеж.

# След това трябва да дефинираме оператора evaluate като псевдоним на функцията oneMaxFitness(), която дефинирахме по-рано.
# Както ще видите по-късно, използването на псевдонима evaluate за изчисление на годността е конвенция в DEAP:

toolbox.register("evaluate", oneMaxFitness)

# Както беше споменато в предишния раздел, генетичните оператори обикновено се създават чрез задаване на псевдоними на съществуващи 
# функции от модула tools и настройване на стойностите на техните аргументи при нужда.

# Тук сме избрали следните оператори:

# Турнирна селекция с размер на турнира 3.
# Кръстосване с една точка (single-point crossover).
# Мутация чрез обръщане на бит (flip-bit mutation).

# Забележка за параметъра indpb във функцията mutFlipBit:

# Функцията mutFlipBit итерира през всички атрибути на индивида – в нашия случай, списък със стойности 1 и 0. Всеки атрибут 
# използва стойността на параметъра indpb като вероятност за обръщане (прилагане на логическия оператор not) на стойността на атрибута.

# Важно уточнение:
# Стойността на indpb е независима от вероятността за мутация, зададена чрез константата P_MUTATION, която дефинирахме по-рано.
# Вероятността за мутация (P_MUTATION) решава дали функцията mutFlipBit ще бъде извикана за даден индивид от популацията.

toolbox.register("select", tools.selTournament, tournsize=3)  # Турнирна селекция с размер 3
toolbox.register("mate", tools.cxOnePoint)                    # Кръстосване с една точка
toolbox.register("mutate", tools.mutFlipBit, indpb=1.0/ONE_MAX_LENGTH)  # Мутация чрез обръщане на бит

# Evolving the solution