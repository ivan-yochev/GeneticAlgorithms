# Подготовка

# Преди да започнем с основния поток на генетичния алгоритъм, трябва да направим първоначалната настройка. Рамката 
# DEAP предлага специфичен начин за това, както е показано в следните стъпки:

# 1. Импортиране на необходимите модули:
# Започваме с импортиране на основните модули на DEAP, заедно с някои полезни библиотеки:

from deap import base      # Основни класове като Toolbox
from deap import creator   # Създаване на класове Fitness и Individual
from deap import tools     # Инструменти за генетични оператори
import random              # Генериране на случайни числа
import matplotlib.pyplot as plt  # За визуализация на резултатите


# Деклариране на константи

# Следващата стъпка е да дефинираме няколко константи, които определят параметрите на задачата и контролират
# поведението на генетичния алгоритъм.

# Код за дефиниране на константи:

# Константи за задачата:
ONE_MAX_LENGTH = 100  # Дължина на бинарния низ, който ще бъде оптимизиран

# Константи за генетичния алгоритъм:
POPULATION_SIZE = 200  # Брой индивиди в популацията
P_CROSSOVER = 0.9      # Вероятност за кръстосване
P_MUTATION = 0.1       # Вероятност за мутация на индивид
MAX_GENERATIONS = 50   # Максимален брой поколения (условие за спиране)

# Настройване на случайността

# Важен аспект на генетичния алгоритъм е използването на вероятност, която въвежда елемент на случайност в поведението му.
# Въпреки това, по време на експериментиране с кода, може да искаме да изпълним един и същ експеримент няколко пъти и да получим
# повторими резултати.

# За да постигнем това, трябва да зададем случайния seed на константна стойност, както е показано:

RANDOM_SEED = 42
random.seed(RANDOM_SEED)

# Съвет:
# На някакъв етап може да решите да премахнете тези редове код, за да позволите на различните изпълнения на алгоритъма да
# произвеждат леко различни резултати.

# Използване на класа Toolbox за създаване на оператора zeroOrOne

# Както видяхме по-рано в тази глава, класът Toolbox е една от основните помощни функции, предоставени от DEAP.
# Той ни позволява да регистрираме нови функции (или оператори), като персонализираме съществуващи функции чрез 
# предварително зададени аргументи.

# Създаване на оператора zeroOrOne:
# В този случай ще използваме Toolbox, за да създадем оператора zeroOrOne, който персонализира функцията random.randint(a, b).

# Функцията random.randint(a, b) обикновено връща случайно цяло число 
# a ≤ N ≤ b. 
# Чрез фиксиране на стойностите на 

# a и b на 0 и 1, операторът zeroOrOne ще връща на случаен принцип 0 или 1, когато бъде извикан.
# Код за създаване на zeroOrOne:

toolbox = base.Toolbox()
toolbox.register("zeroOrOne", random.randint, 0, 1)

# Създаване на класа Fitness

# Следващата стъпка е да създадем класа Fitness. Тъй като задачата има само една цел – максимизиране на сумата от цифрите – ще
# използваме стратегията FitnessMax и ще зададем кортеж weights с една положителна стойност.

# Код за създаване на класа Fitness:

creator.create("FitnessMax", base.Fitness, weights=(1.0,))

# Обяснение:
# FitnessMax:
# Името на новия клас, който създаваме, представляващ стратегия за максимизиране на годността.
# base.Fitness:
# Базовият клас, който разширяваме, за да дефинираме класа FitnessMax.
# weights=(1.0,):
# Кортеж със стойност 
# 1.0
# 1.0, което означава, че целта е да максимизираме годността.
# Важно: Запетаята е задължителна, тъй като weights трябва да бъде кортеж, дори когато съдържа само една стойност.

# Създаване на класа Individual

# В DEAP конвенцията е да се използва клас, наречен Individual, за да представлява всеки от индивидите в популацията. 
# Този клас се създава с помощта на инструмента creator. В нашия случай, list служи като базов клас, който се използва като 
# хромозома на индивида. Класът се допълва с атрибут fitness, инициализиран към класа FitnessMax, който дефинирахме по-рано:

creator.create("Individual", list, fitness=creator.FitnessMax)


# След това трябва да регистрираме оператора individualCreator, който създава инстанция на класа Individual, запълнена със случайни 
# стойности 0 или 1. Това се прави, като използваме предварително дефинирания оператор zeroOrOne. Тази дефиниция използва оператора 
# initRepeat, споменат по-рано, като базов клас. Той може да бъде персонализиран със следните аргументи:

# Класът Individual може да бъде използван като типа на контейнера, в който ще бъдат поставени резултатните обекти.
# Операторът zeroOrOne може да бъде използван като функция за генериране на обекти.
# Константата ONE_MAX_LENGTH може да бъде използвана като броя на обектите, които искаме да генерираме (в момента зададена на 100).
# Тъй като обектите, генерирани от оператора zeroOrOne, са цели числа със случайни стойности 0 или 1, резултатният оператор
# individualCreator ще запълни инстанция на Individual със 100 случайно генерирани стойности от 0 или 1:

toolbox.register("individualCreator", 
                 tools.initRepeat, 
                 creator.Individual, 
                 toolbox.zeroOrOne, ONE_MAX_LENGTH)

# Накрая, трябва да регистрираме оператора populationCreator, който създава списък от индивиди.

# Тази дефиниция също използва оператора initRepeat, със следните аргументи:

# Класът list се използва като типа на контейнера.
# Операторът individualCreator, дефиниран по-рано, се използва като функция за генериране на обектите в списъка.
# Последният аргумент на initRepeat – броят на обектите, които искаме да генерираме – не е зададен тук. Това означава, че при
# използването на оператора populationCreator този аргумент ще бъде очакван и ще се използва за определяне на броя на създадените
# индивиди – с други думи, размера на популацията:

toolbox.register("populationCreator", 
                 tools.initRepeat, 
                 list, toolbox.individualCreator)

# За да улесним изчисляването на годността (или оценката, според терминологията на DEAP), трябва да дефинираме отделна функция, 
# която приема инстанция на класа Individual и връща нейната годност.

# Тук дефинираме функция, наречена oneMaxFitness, която изчислява броя на единиците (1) в индивида. Тъй като индивидът по същество
# е списък със стойности 0 или 1, можем да използваме вградената Python функция sum() за тази цел:

def oneMaxFitness(individual):
    return sum(individual),  # връща кортеж

# Обяснение:
# individual: Инстанция на класа Individual, представляваща индивид.
# sum(individual): Изчислява сумата на елементите в списъка, което е броят на единиците в индивида.
# Запетаята в края: Указва, че функцията връща кортеж (изискване на DEAP за стойностите на годността).

# Съвет
# Както беше споменато по-рано, стойностите на годността в DEAP се представят като кортежи. Следователно, когато функцията връща
# само една стойност, трябва да добавим запетая след нея, за да я направим кортеж.

# След това трябва да дефинираме оператора evaluate като псевдоним на функцията oneMaxFitness(), която дефинирахме по-рано.
# Както ще видите по-късно, използването на псевдонима evaluate за изчисление на годността е конвенция в DEAP:

toolbox.register("evaluate", oneMaxFitness)

# Както беше споменато в предишния раздел, генетичните оператори обикновено се създават чрез задаване на псевдоними на съществуващи 
# функции от модула tools и настройване на стойностите на техните аргументи при нужда.

# Тук сме избрали следните оператори:

# Турнирна селекция с размер на турнира 3.
# Кръстосване с една точка (single-point crossover).
# Мутация чрез обръщане на бит (flip-bit mutation).

# Забележка за параметъра indpb във функцията mutFlipBit:

# Функцията mutFlipBit итерира през всички атрибути на индивида – в нашия случай, списък със стойности 1 и 0. Всеки атрибут 
# използва стойността на параметъра indpb като вероятност за обръщане (прилагане на логическия оператор not) на стойността на атрибута.

# Важно уточнение:
# Стойността на indpb е независима от вероятността за мутация, зададена чрез константата P_MUTATION, която дефинирахме по-рано.
# Вероятността за мутация (P_MUTATION) решава дали функцията mutFlipBit ще бъде извикана за даден индивид от популацията.

toolbox.register("select", tools.selTournament, tournsize=3)  # Турнирна селекция с размер 3
toolbox.register("mate", tools.cxOnePoint)                    # Кръстосване с една точка
toolbox.register("mutate", tools.mutFlipBit, indpb=1.0/ONE_MAX_LENGTH)  # Мутация чрез обръщане на бит

# Evolving the solution

def main():
    # Започваме потока, като създаваме началната популация с помощта на оператора populationCreator, който дефинирахме по-рано, 
    # и след това използваме константата POPULATION_SIZE като аргумент за този оператор. Променливата generationCounter, която
    # ще бъде използвана по-късно, също се инициализира тук:


    population = toolbox.populationCreator(n=POPULATION_SIZE)
    generationCounter = 0

    # За да изчислим годността за всеки индивид в началната популация, можем да използваме функцията map() на Python, за да приложим 
    # оператора evaluate към всеки елемент от популацията.

    # Тъй като операторът evaluate е псевдоним за функцията oneMaxFitness(), резултатният итератор се състои от изчислените кортежи на 
    # годност за всеки индивид. След това той се преобразува в списък от кортежи:

    fitnessValues = list(map(toolbox.evaluate, population))

    # Тъй като елементите на fitnessValues съответстват на тези в популацията (която е списък от индивиди), можем да използваме функцията
    #  zip() за да ги комбинираме и да присвоим съответстващия кортеж за годност на всеки индивид:

    for individual, fitnessValue in zip(population, fitnessValues):
        individual.fitness.values = fitnessValue

    # След това, тъй като имаме годност с една цел, трябва да извлечем първата стойност от всяка годност, за да съберем статистика:

    fitnessValues = [individual.fitness.values[0] for individual in population]

    # Събраните статистики ще бъдат максималната стойност на годността и средната (осреднена) стойност на годността за всяко поколение.
    #  За тази цел ще използваме два списъка. Нека ги създадем:

    maxFitnessValues = []
    meanFitnessValues = []

    # Накрая сме готови за основния цикъл на генетичния поток. В началото на цикъла са зададени условията за спиране. Както решихме
    # по-рано, едното условие за спиране ще бъде ограничение на броя поколения, а другото ще бъде откриването на най-доброто решение 
    # (бинарен низ, съдържащ само единици):

    while max(fitnessValues) < ONE_MAX_LENGTH and generationCounter < MAX_GENERATIONS:
        # Следващата стъпка е да се актуализира броячът на поколенията. Той се използва както за условието за спиране, така и за командите
        # за печат, които ще видим скоро:
        generationCounter = generationCounter + 1

        # В основата на генетичния алгоритъм са генетичните оператори, които се прилагат следващи. Първият е операторът за селекция, 
        # който може да бъде приложен чрез оператора toolbox.select, дефиниран по-рано като турнирна селекция.

        # Тъй като вече зададохме размера на турнира при дефиницията на оператора, сега е нужно само да подадем популацията и нейната 
        # дължина като аргументи:

        offspring = toolbox.select(population, len(population))

        # Избраните индивиди, които сега се намират в списък, наречен offspring, трябва да бъдат клонирани, за да можем да приложим
        # следващите генетични оператори, без да повлияем на оригиналната популация:

        offspring = list(map(toolbox.clone, offspring))

        # Важна забележка
        # Въпреки името offspring (потомци), те все още са клонинги на индивиди от предишното поколение. Все още трябва да ги комбинираме
        # чрез оператора за кръстосване, за да създадем реалните потомци.

        # Следващият генетичен оператор е кръстосването.
        # Той беше дефиниран по-рано като оператор toolbox.mate, представляващ кръстосване с една точка (single-point crossover).

        # Използваме разширени срезове (extended slices) на Python, за да сдвоим всеки елемент с четен индекс от списъка offspring с този,
        # който го следва. След това използваме функцията random() за "хвърляне на монета" с вероятността за кръстосване, зададена 
        # чрез константата   P_CROSSOVER. Това ще реши дали двойката индивиди ще бъде кръстосана или ще остане непроменена.
        # Накрая изтриваме стойностите на годността на децата, тъй като те са били модифицирани и вече не са валидни:

        for child1, child2 in zip(offspring[::2], offspring[1::2]):
            if random.random() < P_CROSSOVER:
                toolbox.mate(child1, child2)
                del child1.fitness.values
                del child2.fitness.values


        # Важна забележка
        # Функцията mate приема два индивида като аргументи и ги модифицира директно на място, което означава, че няма нужда да бъдат 
        # преприсвоявани.

        # Последният генетичен оператор е мутацията.
        # Той беше регистриран по-рано като оператор toolbox.mutate и беше зададен да бъде мутация чрез обръщане на битове 
        # (flip-bit mutation).

        # Итерация над всички елементи на offspring:
        # Операторът за мутация ще бъде приложен с вероятност, зададена чрез константата за вероятност на мутация P_MUTATION.
        # Изтриване на годността на индивида:
        # Ако даден индивид бъде модифициран чрез мутация, трябва да изтрием неговата стойност за годност (fitness.values), ако такава
        #  съществува.
        # Стойността за годност може да е била пренесена от предишното поколение, но след мутация вече не е валидна и трябва да 
        # бъде преизчислена.

        for mutant in offspring:
            if random.random() < P_MUTATION:
                toolbox.mutate(mutant)       # Приложение на мутация
                del mutant.fitness.values    # Изтриване на годността, ако съществува

        # Индивидите, които не са били кръстосани или мутирали, остават непроменени, и следователно техните съществуващи стойности за 
        # годност, които вече са изчислени в предишно поколение, не е нужно да бъдат преизчислявани.

        # Останалите индивиди ще имат празни стойности за годност. Сега трябва да намерим тези нови индивиди, използвайки свойството 
        # valid на класа Fitness, и след това да изчислим новите стойности за годност по същия начин, както при първоначалното изчисление:


        freshIndividuals = [ind for ind in offspring if not ind.fitness.valid]

        freshFitnessValues = list(map(toolbox.evaluate, freshIndividuals))

        for individual, fitnessValue in zip(freshIndividuals, freshFitnessValues):
            individual.fitness.values = fitnessValue

        # Сега, след като генетичните оператори са приложени, е време да заменим старата популация с новата:
        population[:] = offspring

        # Обяснение:

        # population[:] използва срезове, за да замени цялото съдържание на текущата популация със съдържанието на offspring.
        # Това гарантира, че новото поколение замества старото, готово за следващия цикъл.

        # Преди да продължим към следващия цикъл, текущите стойности за годност се събират, за да позволят събирането на статистически
        # данни.

        # Тъй като стойността за годност е кортеж с един елемент, трябва да изберем индекса [0]:

        fitnessValues = [ind.fitness.values[0] for ind in population]

        # Обяснение:

        # ind.fitness.values[0]: Извлича първия (и единствен) елемент от кортежа за годност на всеки индивид.
        # fitnessValues: Списък, съдържащ всички текущи стойности за годност на индивидите в популацията, готов за статистически анализ.


        # Максималните и средните стойности на годността се изчисляват, след което техните стойности се добавят към акумулаторите за 
        # статистика, а обобщение се отпечатва:

        maxFitness = max(fitnessValues)
        meanFitness = sum(fitnessValues) / len(population)
        maxFitnessValues.append(maxFitness)
        meanFitnessValues.append(meanFitness)
        print(f"- Generation {generationCounter}: Max Fitness = {maxFitness}, Avg Fitness = {meanFitness}")

        # Обяснение:
        #     maxFitness = max(fitnessValues):

        #     Изчислява максималната стойност на годността в текущото поколение.
        #     meanFitness = sum(fitnessValues) / len(population):

        #     Изчислява средната стойност на годността в текущото поколение.
        #     Добавяне към акумулаторите:

        #     maxFitnessValues.append(maxFitness): Добавя максималната годност към списъка за статистика.
        #     meanFitnessValues.append(meanFitness): Добавя средната годност към списъка за статистика.
        #     Печат на обобщение:

        #     print(...): Извежда информация за текущото поколение, максималната годност и средната годност.
        #     Това осигурява лесно проследяване на напредъка на генетичния алгоритъм през поколенията.

        # Освен това, трябва да намерим индекса на (първия) най-добър индивид, използвайки максималната стойност на годността, 
        # която току-що изчислихме, и да отпечатаме този индивид:

        best_index = fitnessValues.index(max(fitnessValues))
        print("Best Individual = ", *population[best_index], "\n")

        # Обяснение:
        #     Намиране на индекса на най-добрия индивид:

        #     fitnessValues.index(max(fitnessValues)):
        #     Намира индекса на първия индивид с максималната стойност на годността в текущото поколение.
        #     Отпечатване на най-добрия индивид:

        #     *population[best_index]:
        #     Разопакова съдържанието на индивида (бинарния низ) за четливо отпечатване.
        #     "\n": Добавя празен ред след изхода за по-добра визуализация.
        #     Това позволява лесно наблюдение на най-добрия индивид в текущото поколение и неговия напредък към оптималното решение.


        # След като условие за спиране се активира и потокът на генетичния алгоритъм завърши, можем да използваме акумулаторите за 
        # статистика, за да начертаем графики с помощта на библиотеката matplotlib.

        # Следният код създава графика, илюстрираща развитието на максималните и средните стойности на годността през поколенията:


    plt.plot(maxFitnessValues, color='red')    # Максимална годност (в червено)
    plt.plot(meanFitnessValues, color='green') # Средна годност (в зелено)
    plt.xlabel('Generation')                   # Надпис на оста X
    plt.ylabel('Max / Average Fitness')        # Надпис на оста Y
    plt.title('Max and Average Fitness over Generations') # Заглавие на графиката
    plt.show()                                 # Показване на графиката

    # Обяснение:
    #     plt.plot(...):

    #     Начертава линиите за максималната (maxFitnessValues) и средната (meanFitnessValues) годност.
    #     plt.xlabel(...) и plt.ylabel(...):

    #     Определят надписите за осите X и Y.
    #     plt.title(...):

    #     Задава заглавие на графиката.
    #     plt.show():

    #     Показва графиката на екрана.
    #     Тази визуализация дава ясна представа за напредъка на алгоритъма през поколенията. 

if __name__ == "__main__":
    main()

