# “Given a list of cities and the distances between each pair of the cities, find the
# shortest possible path that goes through all the cities and then returns to the
# starting city.”

# http://comopt.ifi.uni-heidelberg.de/software/TSPLIB95/tsp/

# Следващата графика показва най-краткия път за проблема с търговския пътник (TSP), който покрива 15-те най-големи града в Германия:

# В този случай n = 15, така че броят на възможните маршрути е 14!/2, което възлиза на внушителния брой от 43,589,145,600.

# Контекст на търсещите алгоритми:

# Всяка пътека (или частична пътека) през градовете представлява състояние, а множеството от всички възможни пътеки се счита за състояние
# пространство.
# Всяка пътека има съответстваща "цена" – дължината (разстоянието) на пътеката.
# Целта е да намерим пътеката, която минимизира това разстояние.
# Предизвикателство:

# Както отбелязахме, състояние пространството е много голямо, дори за умерен брой градове.
# Това може да направи оценяването на всеки възможен маршрут непрактично скъпо.
# В резултат, макар да е относително лесно да се намери маршрут, който минава през всички градове, намирането на оптималния маршрут 
# може да бъде изключително трудно.


# TSPLIB Benchmark файлове

# TSPLIB е библиотека, съдържаща примерни задачи за проблема с търговския пътник (TSP), базирани на реални географски местоположения
# на градове.

# Библиотеката се поддържа от Университета в Хайделберг, а релевантни примери могат да бъдат намерени тук:
# TSPLIB95 TSP.
# Типове файлове
# На тази уеб страница могат да бъдат намерени два типа файлове:

# .tsp.gz файлове:
# Всеки от тях съдържа описание на конкретен TSP проблем.
# .opt.tour.gz файлове:
# Всеки от тях съдържа оптималното решение за съответния проблем.
# Описание на файловете
# Файловете, описващи проблемите, са текстови и използват разделители от типа на празно място.
# Типичен файл съдържа няколко информационни реда, последвани от данни за градовете.
# Интересни за нас са файловете, които включват x, y координати на участващите градове, за да можем да ги визуализираме.
# Пример: burma14.tsp.gz
# След разархивиране, съдържанието на файла изглежда така (някои редове са пропуснати за краткост):

# NODE_COORD_SECTION  
# 1 16.47 96.10  
# 2 16.47 94.44  
# 3 20.09 92.54  
# ...  
# EOF  

# Интересен за нас сегмент
# Редовете между NODE_COORD_SECTION и EOF съдържат координатите на градовете.
# В някои файлове вместо NODE_COORD_SECTION се използва DISPLAY_DATA_SECTION.
# Готови ли сме да решим примерен проблем?
# Преди да започнем, трябва да разберем как ще бъде представено потенциалното решение. Това ще бъде разгледано в следващия подраздел.

# Представяне на решението

# При решаването на TSP (проблема с търговския пътник), градовете обикновено се представят чрез числа от 0 до n-1, а възможните
# решения са последователности от тези числа.

# Пример за проблем с пет града може да има решения като:
# [0, 1, 2, 3, 4]
# [2, 4, 3, 1, 0]
# Оценяване на решенията:
# Всяко решение се оценява чрез:

# Изчисляване и сумиране на разстоянията между всеки два последователни града в маршрута.
# Добавяне на разстоянието между последния град и първия, за да се затвори маршрута.
# Генетичен алгоритъм за този проблем:
# За целите на генетичния алгоритъм можем да използваме списък от цели числа (последователност от номера на градове) като хромозома.
# Python клас за TSP
# Описаният в следващия подраздел Python клас чете съдържанието на файловете от TSPLIB.
# Той извършва следните задачи:
# Изчислява разстоянията между всеки два града.
# Изчислява общото разстояние, покрито от дадено потенциално решение, използвайки представянето чрез списък, което обсъдихме.

# Представяне на проблема чрез Python

# За капсулиране на проблема с търговския пътник (TSP) е създаден Python клас, наречен TravelingSalesmanProblem.
# Този клас се намира във файла tsp.py, който може да бъде намерен на адрес:
# GitHub - TSP Python Code.

# Методи на класа:
# Приватни методи:
# __create_data():

# Чете желания TSPLIB файл.
# Извлича координатите на всички градове.
# Изчислява разстоянията между всеки два града.
# Попълва матрица на разстоянията (двуизмерен масив).
# Сериализира (записва) местоположенията на градовете и изчислените разстояния на диск, използвайки модула pickle.
# __read_data():

# Чете сериализираните данни.
# Ако данните не са налични, извиква __create_data(), за да ги подготви.
# Тези методи се извикват вътрешно от конструктора, така че данните се инициализират веднага след създаването на инстанция на класа.

# Публични методи:
# getTotalDistance(indices):

# Изчислява общото разстояние на маршрута, описан от подадения списък с индекси на градове.
# plotData(indices):

# Изобразява графично маршрута, описан от подадения списък с индекси на градове.
# Главен метод на класа:
# Главният метод демонстрира употребата на методите на класа.
# Стъпки:
# Създава TSP проблема bayg29 (29 града в Бавария).
# Изчислява разстоянието за оптималното решение (описано във файла .opt.tour).
# Показва графично маршрута.
# Ако изпълним този клас като самостоятелна Python програма, изходът ще изглежда така:

# problem name: bayg29
# Optimal solution =  [0, 27, 5, 11, 8, 25, 2, 28, 4, 20, 1, 19, 9, 3, 14, 17, 13, 16, 21, 10, 18, 24, 6, 22, 7, 26, 15, 12, 23]
# Optimal distance =  9074.147

#page 95/118

# Решение чрез генетичен алгоритъм

# За първия ни опит да решим проблема с търговския пътник (TSP) чрез генетичен алгоритъм създадохме Python
# програмата 02-solve-tsp-first-attempt.py, която се намира на адрес:
# GitHub - Решение на TSP.

# Основните части на нашето решение са описани в следните стъпки:

# Програмата започва със създаване на инстанция на проблема bayg29, както следва:

# TSP_NAME = "bayg29"
# tsp = tsp.TravelingSalesmanProblem(TSP_NAME)

# След това трябва да дефинираме стратегията за пригодност (fitness strategy).
# Тук искаме да минимизираме разстоянието, което се изразява в едноцелеви клас за минимизираща пригодност
# (single-objective minimizing fitness class), дефиниран с едно отрицателно тегло:

# creator.create("FitnessMin", base.Fitness, weights=(-1.0,))

# Както обсъдихме по-рано, нашият избор на хромозома за генетичния алгоритъм е списък от цели числа от 0 до n-1, където n е 
# броят на градовете, представляващи индексите на градовете.
# Например, оптималното решение за проблема “bayg29”, което видяхме по-рано, беше представено със следната хромозома:

# [0, 27, 5, 11, 8, 25, 2, 28, 4, 20, 1, 19, 9, 3, 14, 17, 13,
# 16, 21, 10, 18, 24, 6, 22, 7, 26, 15, 12, 23]

# Следният кодов фрагмент е отговорен за имплементирането на тази хромозома. По-долу е предоставено и обяснение:

# creator.create("Individual", array.array, typecode='i',
#                fitness=creator.FitnessMin)
# toolbox.register("randomOrder", random.sample,
#                  range(len(tsp)), len(tsp))
# toolbox.register("individualCreator", tools.initIterate,
#                  creator.Individual, toolbox.randomOrder)
# toolbox.register("populationCreator", tools.initRepeat, list,
#                  toolbox.individualCreator)

# Обяснение GTP :
# Създаване на класа Individual:

# Класът Individual разширява array.array (тип за работа с масиви).
# Типът на елементите в масива е зададен чрез typecode='i', което означава целочислени стойности.
# Хромозомата получава атрибут fitness, който се инициализира като creator.FitnessMin за минимизиране на разстоянието.
# toolbox.randomOrder:

# Регистрира се функция, която създава случаен ред от числата в диапазона от 0 до len(tsp) - 1 (индексите на градовете).
# Използва се функцията random.sample за генериране на произволна подредба.
# toolbox.individualCreator:

# Създава индивид (хромозома) чрез инициализиране с функцията toolbox.randomOrder, която генерира произволна подредба.
# toolbox.populationCreator:

# Създава популация като списък от индивиди, създадени от toolbox.individualCreator.
# Използва се функцията tools.initRepeat, за да се генерират множество индивиди.

# Класът Individual се създава първо, като разширява масив от цели числа и го допълва с класа FitnessMin.

# Операторът randomOrder се регистрира след това, за да предостави резултати от извикването на random.sample() върху диапазон, 
# определен от дължината на TSP проблема (броя на градовете, n).
# Това води до генериране на случаен списък с индекси между 0 и n-1.

# След това се създава операторът IndividualCreator. Когато бъде извикан, той ще използва оператора randomOrder и ще итерира 
# върху резултатите, за да създаде валидна хромозома, съставена от индексите на градовете.

# Последният оператор, populationCreator, се създава, за да генерира списък от индивиди, използвайки оператора IndividualCreator.

# Класът Individual се създава първо, като разширява масив от цели числа и го допълва с класа FitnessMin.

# Операторът randomOrder се регистрира след това, за да предостави резултати от извикването на random.sample() върху диапазон,
# определен от дължината на TSP проблема (броя на градовете, n).
# Това води до генериране на случаен списък с индекси между 0 и n-1.

# След това се създава операторът IndividualCreator. Когато бъде извикан, той ще използва оператора randomOrder и ще итерира
# върху резултатите, за да създаде валидна хромозома, съставена от индексите на градовете.

# Последният оператор, populationCreator, се създава, за да генерира списък от индивиди, използвайки оператора IndividualCreator.

# Сега, след като хромозомата е имплементирана, е време да дефинираме функцията за оценка на пригодността (fitness evaluation function).
# Това се осъществява чрез функцията tpsDistance(), която директно използва метода getTotalDistance() на класа TravelingSalesmanProblem:

# def tpsDistance(individual):
#     return tsp.getTotalDistance(individual), # връща кортеж

# toolbox.register("evaluate", tpsDistance)

# Обяснение:
# tpsDistance(individual):

# Приема индивид като аргумент.
# Извиква tsp.getTotalDistance(individual), за да изчисли общото разстояние за дадената подредба на градовете.
# Резултатът се връща като кортеж, което е стандартен формат за DEAP.
# Регистрация в toolbox:

# Функцията tpsDistance се регистрира като оператор evaluate.
# Операторът ще се използва от генетичния алгоритъм за изчисление на пригодността на всеки индивид.

# След това трябва да дефинираме генетичните оператори.
# За оператора на селекция можем да използваме турнирна селекция с размер на турнира 3, както направихме в предишните случаи:

# toolbox.register("select", tools.selTournament, tournsize=3)

# Обяснение:
# toolbox.register: Регистрира оператора на селекция.
# tools.selTournament: Избира индивидите чрез турнирна селекция.
# tournsize=3: Указва, че във всеки турнир ще участват 3 индивида, от които ще бъде избран най-добрият за следващото поколение.

# Въпреки това, преди да изберем операторите за кръстосване (crossover) и мутация (mutation), трябва да помним, че хромозомата, 
# която използваме, не е просто списък от цели числа, а списък от индекси (или подреден списък), който представлява реда на градовете.
# Затова не можем просто да смесим части от два списъка или произволно да променим индекс в списъка. Вместо това, трябва да
# използваме специализирани оператори, които са проектирани да произвеждат валидни списъци с индекси.

# В глава 2 (Understanding the Key Components of Genetic Algorithms) разгледахме няколко такива оператора, включително ordered 
# crossover и scramble mutation.
# Тук използваме съответните реализации в DEAP – cxOrdered и mutShuffleIndexes:

# toolbox.register("mate", tools.cxOrdered)
# toolbox.register("mutate", tools.mutShuffleIndexes,
#                  indpb=1.0/len(tsp))

# Обяснение:
# toolbox.register("mate", tools.cxOrdered):

# Регистрира cxOrdered като оператор за кръстосване.
# cxOrdered изпълнява ordered crossover, който гарантира, че резултатните хромозоми (децата) ще бъдат валидни подредби на градовете.
# toolbox.register("mutate", tools.mutShuffleIndexes, indpb=1.0/len(tsp)):

# Регистрира mutShuffleIndexes като оператор за мутация.
# mutShuffleIndexes изпълнява scramble mutation, която разбърква индекси в хромозомата, като запазва валидността на подредбата.
# indpb=1.0/len(tsp): Вероятността всеки индекс в списъка да бъде разбъркан е обратно пропорционална на дължината на списъка 
# (броя на градовете).

# Накрая е време да извикаме изпълнението на генетичния алгоритъм.
# Тук използваме вградения алгоритъм eaSimple на DEAP с нашите обекти stats и halloffame, за да осигурим информация,
# която можем да визуализираме по-късно:

# population, logbook = algorithms.eaSimple(
#     population,
#     toolbox,
#     cxpb=P_CROSSOVER,
#     mutpb=P_MUTATION,
#     ngen=MAX_GENERATIONS,
#     stats=stats,
#     halloffame=hof,
#     verbose=True
# )

# Обяснение:
# population и logbook:

# Алгоритъмът връща:
# population – последното поколение индивиди.
# logbook – събира информация за статистиките от всяка итерация.
# Параметри на алгоритъма:

# population: Началната популация.
# toolbox: Съдържа дефинираните оператори за селекция, кръстосване, мутация и оценка.
# cxpb: Вероятността за кръстосване (в случая 0.9).
# mutpb: Вероятността за мутация (в случая 0.1).
# ngen: Максималният брой поколения (в случая 200).
# stats: Обект за събиране на статистики.
# halloffame: Обект за запис на най-добрите индивиди.
# verbose=True: Активира печат на подробна информация за всяко поколение.
# Резултати:
# Когато програмата се изпълни с предварително зададените стойности на константите (размер на популацията 300, 200 поколения,
# вероятност за кръстосване 0.9 и вероятност за мутация 0.1), получаваме следните резултати:

# Алгоритъмът ефективно намира решения, които можем да анализираме чрез logbook и halloffame.

# Най-добрата намерена стойност на фитнеса (9549.98) е сравнително близо до известното оптимално разстояние от 9074.14.
# Програмата след това генерира два графика:

# Първият график илюстрира пътя на най-добрия индивид, открит по време на изпълнението на алгоритъма.
# Вторият график показва статистиката на генетичния поток. Забележете, че този път избрахме да събираме данни за минималната стойност 
# на фитнеса, а не за максималната, тъй като целта на този проблем е да минимизираме разстоянието.
# Анализ и подобрения:
# Тъй като сме намерили добро решение, но не и най-доброто известно, можем да изпробваме начини за подобряване на резултатите:

# Експериментиране с параметри: Можем да променим размера на популацията, броя на поколенията и вероятностите за кръстосване и мутация.
# Смяна на генетични оператори: Можем да заменим използваните оператори с други, съвместими с проблема.
# Промяна на случайното засяване (random seed): Можем да изпробваме различни стойности, за да видим как влияят на резултатите.
# Множество изпълнения: Можем да направим няколко изпълнения с различни случайни засявания, за да оценим стабилността на резултатите.
# Следващи стъпки:
# В следващия раздел ще изследваме използването на елитизъм в комбинация с подобрено изследване (exploration), за да постигнем
# по-добри резултати.

# page 99/122

# Подобряване на резултатите чрез разширено изследване и елитизъм
# Ако увеличим броя на поколенията в предишната програма, ще забележим, че решението не се подобрява – алгоритъмът остава „заклещен“ в (донякъде) субоптимално решение, което е достигнато още преди поколение 200.

# Това поведение е илюстрирано в следния график, който показва резултатите за 500 поколения:

# Анализ:
# Тази стагнация показва, че алгоритъмът е достигнал локален оптимум, от който не може да избяга. Това може да се дължи на:

# Липсата на достатъчно генетично разнообразие в популацията.
# Недостатъчно изследване на нови решения в пространството на търсене.
# Решение:
# За да се подобри производителността, можем:

# Да увеличим изследването (exploration):

# Чрез повишаване на честотата и интензивността на мутациите.
# Чрез използване на по-гъвкави оператори за кръстосване.
# Да въведем елитизъм (elitism):

# Да гарантираме, че най-добрите индивиди от всяко поколение се пренасят в следващото непокътнати.
# Това ще предотврати загубата на добри решения по време на селекцията, кръстосването и мутацията.

# От този момент нататък, сходството между средната стойност и най-добрата стойност показва, че това решение е завладяло популацията
# и следователно няма да видим подобрение, освен ако не се появи щастлива мутация. В термините на генетичните алгоритми това
# означава, че експлоатацията е надделяла над изследването. Експлоатацията обикновено означава използване на текущо наличните 
# резултати, докато изследването акцентира върху търсенето на нови решения. Намирането на деликатен баланс между двете може да
# доведе до по-добри резултати.

# Един начин за увеличаване на изследването може да включва намаляване на размера на турнира в използвания алгоритъм за 
# турнирна селекция от 3 на 2:

# toolbox.register("select", tools.selTournament, tournsize=2)

# Както обсъдихме в Глава 2: Разбиране на ключовите компоненти на генетичните алгоритми, това ще увеличи шансовете за селекция на
# по-малко успешни индивиди. Тези индивиди може да носят ключа към по-добри бъдещи решения.

# Въпреки това, ако стартираме същата програма след тази промяна, резултатите са далеч от впечатляващи – най-добрата стойност на 
# фитнеса е над 13,000, а графиката на най-доброто решение изглежда по следния начин:

# Тези слаби резултати могат да бъдат обяснени чрез графиката на статистиката:
# Тази графика показва, че не можем да задържим най-добрите решения. Както става ясно от "шумния" график, който постоянно скача между
# по-добри и по-лоши стойности, добрите решения бързо се "губят" поради по-позволителната схема за селекция, която често позволява
# избор на по-слаби решения.

# Това означава, че сме позволили изследването да отиде твърде далеч и за да балансираме ситуацията, трябва да въведем механизъм за 
# експлоатация. Това може да бъде постигнато чрез механизма на елитизма, който беше въведен за първи път в Глава 2.

# Елитизмът ни позволява да запазим най-добрите решения непокътнати, като им позволяваме да "пропускат" генетичните оператори на 
# селекция, кросоувър и мутация по време на генетичния поток. За да внедрим елитизма, ще трябва да навлезем "под капака" и да
# модифицираме алгоритъма algorithms.eaSimple() на DEAP, тъй като рамката не предоставя директен начин за пропускане на всички 
# три оператора.

# Модифицираният алгоритъм, наречен eaSimpleWithElitism(), може да бъде намерен в файла elitism.py, разположен на:
# GitHub линк към https://github.com/PacktPublishing/Hands-On-Genetic-Algorithms-with-Python-Second-Edition/blob/main/chapter_04/elitism.py

# Методът eaSimpleWithElitism() е подобен на оригиналния eaSimple(), с модификация, при която обектът halloffame се използва за
# внедряване на механизъм за елитизъм. Индивидите, съдържащи се в halloffame, директно се добавят към следващото поколение и не 
# подлежат на генетичните оператори за селекция, кръстосване и мутация. Това на практика се реализира чрез следните промени:

# Вместо да се изберат толкова индивиди, колкото е размерът на популацията, този брой се намалява с броя на индивидите от hall-of-fame:

# offspring = toolbox.select(population,
#                            len(population) - hof_size)

# След прилагането на генетичните оператори, индивидите от hall-of-fame се добавят обратно към популацията:

# offspring.extend(halloffame.items)

# Сега можем да заменим извикването на algorithms.eaSimple() с извикване на elitism.eaSimpleWithElitism(), без да променяме каквито и 
# да било параметри. След това ще зададем стойност на константата HALL_OF_FAME_SIZE равна на 30, което означава, че винаги ще запазваме
# най-добрите 30 индивида в популацията.

# Модифицираната Python програма 03-solve-tsp.py може да бъде намерена на следния адрес:
# https://github.com/PacktPublishing/Hands-On-Genetic-Algorithms-with-Python-Second-Edition/blob/main/chapter_04/03_solve_tsp.py.

# При изпълнение на тази нова програма сега сме в състояние да достигнем оптималното решение.

# Следната графика със статистики показва, че успяхме да премахнем "шума," който наблюдавахме по-рано. Също така успяхме да 
# запазим разлика между средната стойност и най-добрите стойности за значително по-дълго време в сравнение с първоначалния опит.

# В следващата секция ще разгледаме VRP (проблема с планирането на маршрути за превозни средства), който добавя интересен обрат
# към проблема, който току-що решихме.


