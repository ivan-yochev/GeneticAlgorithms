# https://www.youtube.com/@codeinaction1525/playlists

# В тази глава ще научите как генетичните алгоритми могат да бъдат използвани в приложения за комбинаторна оптимизация.

# Ще започнем с описание на търсещите проблеми и комбинаторната оптимизация, като очертаем няколко практически примера за комбинаторни
# оптимизационни проблеми. След това ще анализираме всеки от тези проблеми и ще ги свържем с решения на база Python, използвайки
# рамката DEAP.

# Проблемите за оптимизация, които ще разгледаме:
# Добре известният проблем с раницата (knapsack problem)
# Проблемът на търговския пътник (Traveling Salesman Problem, TSP)
# Проблемът с маршрутизирането на превозни средства (Vehicle Routing Problem, VRP)
# Допълнителни теми:
# Превръщане от генотип към фенотип (genotype-to-phenotype mapping)
# Проучване срещу експлоатация (exploration versus exploitation)
# До края на тази глава ще можете да:
# Разбирате същността на търсещите проблеми и комбинаторната оптимизация
# Решавате проблема с раницата с помощта на генетичен алгоритъм, имплементиран с DEAP
# Решавате TSP с генетичен алгоритъм, имплементиран с DEAP
# Решавате VRP с генетичен алгоритъм, имплементиран с DEAP
# Разбирате превръщането от генотип към фенотип
# Придобиете познания за концепцията проучване срещу експлоатация и връзката ѝ с елитизма


# Търсещи проблеми и комбинаторна оптимизация

# Една от обичайните области за приложение на генетичните алгоритми са търсещите проблеми, които имат важни приложения в области
# като логистика, операции, изкуствен интелект и машинно обучение.

# Примери включват:

# Определяне на оптимални маршрути за доставка на пратки
# Проектиране на авиолинии с хъб-базирани мрежи
# Управление на инвестиционни портфейли
# Разпределяне на пътници към налични шофьори в автопарк от таксита
# Търсещите алгоритми се фокусират върху решаването на даден проблем чрез методично оценяване на състояния и преходи между състояния,
# с цел намиране на път от началното състояние до желано финално (или "целево") състояние.
# Обикновено при всеки преход между състояния има свързана цена или печалба, а целта на съответния търсещ алгоритъм е да намери път, 
# който минимизира цената или максимизира печалбата.

# Тъй като оптималният път е само един от многото възможни, този вид търсене е свързан с комбинаторната оптимизация – област, 
# която включва намирането на оптимален обект от краен, но често изключително голям набор от възможни обекти.

# Тези концепции ще бъдат илюстрирани, докато се запознаваме с проблема с раницата, който е основният фокус на следващия раздел.

#page 84

# Решаване на проблема с раницата

# Помислете за познатата ситуация, когато се подготвяте за дълго пътуване. Има много вещи, които бихте искали да вземете със себе си,
# но сте ограничени от капацитета на своя куфар.
# В съзнанието си всяка вещ има определена стойност, която ще добави към пътуването ви; в същото време тя има размер (и тегло), 
# свързани с нея, и ще се конкурира с другите вещи за наличното пространство в куфара ви.

# Тази ситуация е само един от многото примери от реалния живот за проблема с раницата, който се счита за един от най-старите и 
# най-изследвани комбинаторни търсещи проблеми.

# По-формално, проблемът с раницата се състои от следните компоненти:

# Набор от вещи, всяка от които има определена стойност и определено тегло.
# Чанта/раница/контейнер (т.нар. "раница") с определен капацитет на тегло.

# Нашата цел е да създадем група от избрани вещи, които ще осигурят максимална обща стойност, без да надвишават общия капацитет на 
# тегло на раницата.

# Контекст на търсещите алгоритми:
# Всяко подмножество от вещите представлява състояние, а множеството от всички възможни подмножества се счита за състояние пространство.
# За случай на проблема с раницата 0-1 с n на брой вещи, размерът на състояние пространството е 2ⁿ, което може бързо да нарасне
# много голямо, дори и при умерена стойност на n.
# Версия на проблема – раница 0-1:
# В тази (оригинална) версия на проблема всяка вещ може да бъде включена само веднъж или изобщо не.
# Затова често се нарича проблемът с раницата 0-1 (knapsack 0-1 problem).
# Разширения на проблема:
# Множество включвания:
# Вещите могат да бъдат включени многократно (ограничено или неограничено).
# Множество раници:
# Налични са множество раници с различни капацитети.
# Приложения на проблема с раницата:
# Проблемите с раницата се появяват в много реални процеси, свързани с разпределение на ресурси и вземане на решения, като:

# Избор на инвестиции при изграждане на инвестиционен портфейл.
# Минимизиране на отпадъците при рязане на суровини.
# Извличане на максимална стойност при избиране на въпроси за отговор в ограничено време на тест.

# Описание на проблема може да бъде намерен на : https://rosettacode.org/wiki/Knapsack_problem/0-1

# Представяне на решението

# При решаването на проблема с раницата 0-1, лесен начин за представяне на решение е чрез използване на списък от бинарни стойности.

# Всяка позиция в списъка съответства на един от предметите в проблема.
# Например, за проблема в Rosetta Code, решението може да се представи чрез списък от 22 числа, приемащи стойности 0 или 1.
# Стойност 1 означава, че съответният предмет е избран.
# Стойност 0 означава, че предметът не е избран.
# При прилагане на подхода на генетичните алгоритми, този списък от бинарни стойности ще се използва като хромозома.

# Ограничение: Тегло на избраните предмети
# Трябва да гарантираме, че общото тегло на избраните предмети не надвишава капацитета на раницата.

# Един начин за интегриране на това ограничение е да се изчака оценяването на решението.
# Оценяването се извършва чрез прибавяне на теглата на избраните предмети едно по едно, като се игнорират тези предмети, които 
# биха причинили надвишаване на максимално допустимото тегло.
# От гледна точка на генетичния алгоритъм:
# Хромозомното представяне на индивида (генотип) може да не се изрази изцяло при превода му в действителното решение (фенотип).
# Това означава, че някои от стойностите 1 в хромозомата могат да бъдат игнорирани.
# Тази ситуация е известна като:
# Превод от генотип към фенотип (genotype-to-phenotype mapping).
# Представянето на решението, което описахме, е имплементирано в Python клас, описан в следващия подраздел.

# Представяне на проблема в Python

# За да обобщим проблема с раницата 0-1 от Rosetta Code, създадохме Python клас, наречен Knapsack01Problem.
# Този клас се намира във файла knapsack.py, който може да бъде намерен на адрес:
# https://github.com/PacktPublishing/Hands-On-Genetic-Algorithmswith-Python-Second-Edition/blob/main/chapter_04/knapsack.py.

# Класът предоставя следните методи:

# __init_data():

# Инициализира данните за проблема с раницата 0-1 от RosettaCode.org, като създава списък от кортежи.
# Всеки кортеж съдържа името на предмет, последвано от теглото и стойността му.
# getValue(zeroOneList):

# Изчислява стойността на избраните предмети в списъка, като игнорира предметите, които биха довели до надвишаване на максималното тегло.
# printItems(zeroOneList):

# Отпечатва избраните предмети в списъка, като също игнорира предметите, които биха довели до надвишаване на максималното тегло.
# main() методът на класа:

# Създава инстанция на класа Knapsack01Problem.
# Създава случайно решение и отпечатва релевантната информация за него.
# Ако стартираме този клас като самостоятелна Python програма, примерен изход може да изглежда така:

# Обърнете внимание, че последната поява на 1 в случайното решение, представляваща предмета „калъф за бележки“ (note-case item), 
# стана жертва на превода от генотип към фенотип, обсъден в предишния подраздел.

# Тъй като теглото на този предмет е 22, то би довело до надвишаване на общото тегло от 400.
# В резултат този предмет не беше включен в решението.
# Това случайно решение, както може да се очаква, е далеч от оптимално.

# Нека опитаме да намерим оптималното решение за този проблем, използвайки генетичен алгоритъм.