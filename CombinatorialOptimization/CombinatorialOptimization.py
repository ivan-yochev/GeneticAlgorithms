# https://www.youtube.com/@codeinaction1525/playlists

# В тази глава ще научите как генетичните алгоритми могат да бъдат използвани в приложения за комбинаторна оптимизация.

# Ще започнем с описание на търсещите проблеми и комбинаторната оптимизация, като очертаем няколко практически примера за комбинаторни
# оптимизационни проблеми. След това ще анализираме всеки от тези проблеми и ще ги свържем с решения на база Python, използвайки
# рамката DEAP.

# Проблемите за оптимизация, които ще разгледаме:
# Добре известният проблем с раницата (knapsack problem)
# Проблемът на търговския пътник (Traveling Salesman Problem, TSP)
# Проблемът с маршрутизирането на превозни средства (Vehicle Routing Problem, VRP)
# Допълнителни теми:
# Превръщане от генотип към фенотип (genotype-to-phenotype mapping)
# Проучване срещу експлоатация (exploration versus exploitation)
# До края на тази глава ще можете да:
# Разбирате същността на търсещите проблеми и комбинаторната оптимизация
# Решавате проблема с раницата с помощта на генетичен алгоритъм, имплементиран с DEAP
# Решавате TSP с генетичен алгоритъм, имплементиран с DEAP
# Решавате VRP с генетичен алгоритъм, имплементиран с DEAP
# Разбирате превръщането от генотип към фенотип
# Придобиете познания за концепцията проучване срещу експлоатация и връзката ѝ с елитизма


# Търсещи проблеми и комбинаторна оптимизация

# Една от обичайните области за приложение на генетичните алгоритми са търсещите проблеми, които имат важни приложения в области
# като логистика, операции, изкуствен интелект и машинно обучение.

# Примери включват:

# Определяне на оптимални маршрути за доставка на пратки
# Проектиране на авиолинии с хъб-базирани мрежи
# Управление на инвестиционни портфейли
# Разпределяне на пътници към налични шофьори в автопарк от таксита
# Търсещите алгоритми се фокусират върху решаването на даден проблем чрез методично оценяване на състояния и преходи между състояния,
# с цел намиране на път от началното състояние до желано финално (или "целево") състояние.
# Обикновено при всеки преход между състояния има свързана цена или печалба, а целта на съответния търсещ алгоритъм е да намери път, 
# който минимизира цената или максимизира печалбата.

# Тъй като оптималният път е само един от многото възможни, този вид търсене е свързан с комбинаторната оптимизация – област, 
# която включва намирането на оптимален обект от краен, но често изключително голям набор от възможни обекти.

# Тези концепции ще бъдат илюстрирани, докато се запознаваме с проблема с раницата, който е основният фокус на следващия раздел.

#page 84

# Решаване на проблема с раницата

# Помислете за познатата ситуация, когато се подготвяте за дълго пътуване. Има много вещи, които бихте искали да вземете със себе си,
# но сте ограничени от капацитета на своя куфар.
# В съзнанието си всяка вещ има определена стойност, която ще добави към пътуването ви; в същото време тя има размер (и тегло), 
# свързани с нея, и ще се конкурира с другите вещи за наличното пространство в куфара ви.

# Тази ситуация е само един от многото примери от реалния живот за проблема с раницата, който се счита за един от най-старите и 
# най-изследвани комбинаторни търсещи проблеми.

# По-формално, проблемът с раницата се състои от следните компоненти:

# Набор от вещи, всяка от които има определена стойност и определено тегло.
# Чанта/раница/контейнер (т.нар. "раница") с определен капацитет на тегло.

# Нашата цел е да създадем група от избрани вещи, които ще осигурят максимална обща стойност, без да надвишават общия капацитет на 
# тегло на раницата.

# Контекст на търсещите алгоритми:
# Всяко подмножество от вещите представлява състояние, а множеството от всички възможни подмножества се счита за състояние пространство.
# За случай на проблема с раницата 0-1 с n на брой вещи, размерът на състояние пространството е 2ⁿ, което може бързо да нарасне
# много голямо, дори и при умерена стойност на n.
# Версия на проблема – раница 0-1:
# В тази (оригинална) версия на проблема всяка вещ може да бъде включена само веднъж или изобщо не.
# Затова често се нарича проблемът с раницата 0-1 (knapsack 0-1 problem).
# Разширения на проблема:
# Множество включвания:
# Вещите могат да бъдат включени многократно (ограничено или неограничено).
# Множество раници:
# Налични са множество раници с различни капацитети.
# Приложения на проблема с раницата:
# Проблемите с раницата се появяват в много реални процеси, свързани с разпределение на ресурси и вземане на решения, като:

# Избор на инвестиции при изграждане на инвестиционен портфейл.
# Минимизиране на отпадъците при рязане на суровини.
# Извличане на максимална стойност при избиране на въпроси за отговор в ограничено време на тест.

# Описание на проблема може да бъде намерен на : https://rosettacode.org/wiki/Knapsack_problem/0-1

# Представяне на решението

# При решаването на проблема с раницата 0-1, лесен начин за представяне на решение е чрез използване на списък от бинарни стойности.

# Всяка позиция в списъка съответства на един от предметите в проблема.
# Например, за проблема в Rosetta Code, решението може да се представи чрез списък от 22 числа, приемащи стойности 0 или 1.
# Стойност 1 означава, че съответният предмет е избран.
# Стойност 0 означава, че предметът не е избран.
# При прилагане на подхода на генетичните алгоритми, този списък от бинарни стойности ще се използва като хромозома.

# Ограничение: Тегло на избраните предмети
# Трябва да гарантираме, че общото тегло на избраните предмети не надвишава капацитета на раницата.

# Един начин за интегриране на това ограничение е да се изчака оценяването на решението.
# Оценяването се извършва чрез прибавяне на теглата на избраните предмети едно по едно, като се игнорират тези предмети, които 
# биха причинили надвишаване на максимално допустимото тегло.
# От гледна точка на генетичния алгоритъм:
# Хромозомното представяне на индивида (генотип) може да не се изрази изцяло при превода му в действителното решение (фенотип).
# Това означава, че някои от стойностите 1 в хромозомата могат да бъдат игнорирани.
# Тази ситуация е известна като:
# Превод от генотип към фенотип (genotype-to-phenotype mapping).
# Представянето на решението, което описахме, е имплементирано в Python клас, описан в следващия подраздел.

# Представяне на проблема в Python

# За да обобщим проблема с раницата 0-1 от Rosetta Code, създадохме Python клас, наречен Knapsack01Problem.
# Този клас се намира във файла knapsack.py, който може да бъде намерен на адрес:
# https://github.com/PacktPublishing/Hands-On-Genetic-Algorithmswith-Python-Second-Edition/blob/main/chapter_04/knapsack.py.

# Класът предоставя следните методи:

# __init_data():

# Инициализира данните за проблема с раницата 0-1 от RosettaCode.org, като създава списък от кортежи.
# Всеки кортеж съдържа името на предмет, последвано от теглото и стойността му.
# getValue(zeroOneList):

# Изчислява стойността на избраните предмети в списъка, като игнорира предметите, които биха довели до надвишаване на максималното тегло.
# printItems(zeroOneList):

# Отпечатва избраните предмети в списъка, като също игнорира предметите, които биха довели до надвишаване на максималното тегло.
# main() методът на класа:

# Създава инстанция на класа Knapsack01Problem.
# Създава случайно решение и отпечатва релевантната информация за него.
# Ако стартираме този клас като самостоятелна Python програма, примерен изход може да изглежда така:

# Обърнете внимание, че последната поява на 1 в случайното решение, представляваща предмета „калъф за бележки“ (note-case item), 
# стана жертва на превода от генотип към фенотип, обсъден в предишния подраздел.

# Тъй като теглото на този предмет е 22, то би довело до надвишаване на общото тегло от 400.
# В резултат този предмет не беше включен в решението.
# Това случайно решение, както може да се очаква, е далеч от оптимално.

# Нека опитаме да намерим оптималното решение за този проблем, използвайки генетичен алгоритъм.


# За да решим проблема с раницата 0-1, използвайки генетичен алгоритъм, създадохме Python програмата 01-solve-knapsack.py,
# която се намира на адрес:
# https://github.com/PacktPublishing/Hands-On-Genetic-Algorithms-with-Python-Second-Edition/blob/main/chapter_04/01_solve_knapsack.py.

# Напомняне:

# Хромозомното представяне, което решихме да използваме тук, е списък от цели числа със стойности 0 или 1.
# Това прави нашия проблем, от гледна точка на генетичния алгоритъм, подобен на проблема OneMax, който решихме в предишната глава.
# Как работи генетичният алгоритъм:

# Алгоритъмът не се интересува какво представлява хромозомата (т.нар. фенотип) – дали това е:
# Списък от предмети за опаковане,
# Последователност от коефициенти на булева уравнение,
# Или дори реално двоично число.
# Той се фокусира само върху хромозомата (генотипа) и нейната стойност на годност (fitness value).
# Свързването на хромозомата с решението, което тя представлява:

# Това се извършва от функцията за оценка на годността (fitness evaluation function).
# В нашия случай, тази функция е имплементирана чрез метода getValue(), който е капсулиран в класа Knapsack01Problem.
# Заключение:

# Благодарение на тази структура, можем да използваме същата имплементация на генетичния алгоритъм, която използвахме за 
# проблема OneMax, с няколко адаптации.

# Първо, трябва да създадем инстанция на проблема с раницата, който искаме да решим:

# knapsack = knapsack.Knapsack01Problem()

# След това трябва да инструктираме генетичния алгоритъм да използва метода getValue() на тази инстанция за
# оценка на годността (fitness evaluation):

# def knapsackValue(individual):
#     return knapsack.getValue(individual),

# toolbox.register("evaluate", knapsackValue)

# Генетичните оператори, които се използват, са съвместими с хромозомата, представляваща бинарен списък:

# toolbox.register("select", tools.selTournament, tournsize=3)
# toolbox.register("mate", tools.cxTwoPoint)
# toolbox.register("mutate", tools.mutFlipBit, indpb=1.0/len(knapsack))

# След като генетичният алгоритъм спре, можем да използваме метода printItems(), за да отпечатаме 
# в удобен формат най-доброто намерено решение:

# best = hof.items[0]
# print("-- Knapsack Items = ")
# knapsack.printItems(best)

# Настройки на параметрите на генетичния алгоритъм:

# Тъй като този конкретен проблем използва бинарен низ с дължина 22, той изглежда по-лесен от проблема OneMax с 
# дължина 100, който решихме по-рано.
# Затова можем вероятно да намалим размера на популацията и максималния брой поколения.
# При изпълнение на алгоритъма за 50 поколения с популация от 50 индивида, получаваме следния резултат:

# Общата стойност от 1030 е известното оптимално решение за този проблем.

# Тук също се вижда, че последната поява на стойност 1 в хромозомата на най-добрия индивид, представляваща предмета книга (book),
# е била жертвана в реалното решение при превода от генотип към фенотип.
# Това е направено, за да се избегне надвишаването на лимита от 400 за натрупаното тегло.
# Следващата графика, която изобразява максималната и средната годност (fitness) през поколенията, показва, че оптималното решение
# е било намерено за по-малко от 10 поколения:

# В следващия раздел ще сменим темпото и ще се заемем с по-сложна, но все пак класическа, комбинаторна задача за търсене,
# известна като проблема с търговския пътник (TSP).

# page 91